{"version":3,"file":"browser.global.js","sources":["../src/array/at.ts","../src/array/difference.ts","../src/array/differenceBy.ts","../src/array/differenceWith.ts","../src/array/dropRightWhile.ts","../src/array/dropWhile.ts","../src/array/flatten.ts","../src/array/intersection.ts","../src/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/array/last.ts","../src/array/pull.ts","../src/array/sample.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/array/uniq.ts","../src/array/uniqBy.ts","../src/array/unionBy.ts","../src/array/uniqWith.ts","../src/array/unionWith.ts","../src/array/unzip.ts","../src/array/zip.ts","../src/error/AbortError.ts","../src/error/TimeoutError.ts","../src/function/after.ts","../src/function/ary.ts","../src/function/debounce.ts","../src/function/flow.ts","../src/function/identity.ts","../src/function/noop.ts","../src/function/partial.ts","../src/function/partialRight.ts","../src/promise/delay.ts","../src/promise/semaphore.ts","../src/promise/timeout.ts","../src/function/retry.ts","../src/math/mean.ts","../src/math/sum.ts","../src/math/median.ts","../src/math/range.ts","../src/predicate/isPrimitive.ts","../src/predicate/isTypedArray.ts","../src/object/clone.ts","../src/compat/_internal/getSymbols.ts","../src/compat/_internal/getTag.ts","../src/compat/_internal/tags.ts","../src/object/cloneDeepWith.ts","../src/object/cloneDeep.ts","../src/object/findKey.ts","../src/predicate/isPlainObject.ts","../src/object/flattenObject.ts","../src/object/mapKeys.ts","../src/object/mapValues.ts","../src/object/merge.ts","../src/compat/predicate/isObjectLike.ts","../src/predicate/isBlob.ts","../src/predicate/isBuffer.ts","../src/compat/util/eq.ts","../src/predicate/isEqualWith.ts","../src/predicate/isJSONValue.ts","../src/predicate/isLength.ts","../src/predicate/isNil.ts","../src/predicate/isNull.ts","../src/predicate/isSymbol.ts","../src/predicate/isUndefined.ts","../src/string/capitalize.ts","../src/string/words.ts","../src/string/deburr.ts","../src/string/escape.ts","../src/string/trimEnd.ts","../src/string/trimStart.ts","../src/string/trim.ts","../src/string/unescape.ts","../src/compat/_internal/toArray.ts","../src/compat/predicate/isArrayLike.ts","../src/compat/predicate/isArrayLikeObject.ts","../src/compat/array/last.ts","../src/compat/_internal/flattenArrayLike.ts","../src/compat/_internal/isDeepKey.ts","../src/compat/_internal/toKey.ts","../src/compat/util/toPath.ts","../src/compat/object/get.ts","../src/compat/object/property.ts","../src/compat/predicate/isObject.ts","../src/compat/predicate/isMatch.ts","../src/compat/predicate/matches.ts","../src/compat/object/cloneDeepWith.ts","../src/compat/object/cloneDeep.ts","../src/compat/_internal/isIndex.ts","../src/compat/predicate/isArguments.ts","../src/compat/object/has.ts","../src/compat/predicate/matchesProperty.ts","../src/compat/util/iteratee.ts","../src/compat/predicate/isSymbol.ts","../src/compat/util/toNumber.ts","../src/compat/util/toFinite.ts","../src/compat/util/toInteger.ts","../src/compat/_internal/isIterateeCall.ts","../src/compat/predicate/isString.ts","../src/compat/predicate/isArray.ts","../src/compat/array/flatten.ts","../src/compat/array/forEach.ts","../src/compat/array/head.ts","../src/array/head.ts","../src/compat/array/uniq.ts","../src/compat/array/intersectionWith.ts","../src/compat/_internal/compareValues.ts","../src/compat/_internal/isKey.ts","../src/compat/array/orderBy.ts","../src/compat/predicate/isNaN.ts","../src/compat/predicate/isNil.ts","../src/compat/array/sortedIndexBy.ts","../src/compat/predicate/isNumber.ts","../src/compat/object/set.ts","../src/compat/function/attempt.ts","../src/compat/function/bind.ts","../src/compat/function/bindKey.ts","../src/compat/function/curry.ts","../src/compat/function/curryRight.ts","../src/compat/function/debounce.ts","../src/compat/_internal/decimalAdjust.ts","../src/compat/math/clamp.ts","../src/math/clamp.ts","../src/compat/util/toString.ts","../src/compat/math/sumBy.ts","../src/compat/_internal/isPrototype.ts","../src/compat/predicate/isTypedArray.ts","../src/compat/util/times.ts","../src/compat/object/keysIn.ts","../src/compat/object/assignIn.ts","../src/compat/object/defaults.ts","../src/compat/predicate/isPlainObject.ts","../src/compat/object/mergeWith.ts","../src/compat/object/unset.ts","../src/compat/predicate/conformsTo.ts","../src/compat/predicate/isMap.ts","../src/predicate/isMap.ts","../src/compat/_internal/normalizeForCase.ts","../src/compat/string/escape.ts","../src/compat/string/template.ts","../src/compat/util/invoke.ts","../src/compat/_internal/MAX_SAFE_INTEGER.ts","../src/compat/util/uniqueId.ts","../src/promise/mutex.ts","../src/compat/math/add.ts","../src/compat/function/after.ts","../src/compat/function/ary.ts","../src/function/asyncNoop.ts","../src/compat/function/before.ts","../src/compat/string/camelCase.ts","../src/string/camelCase.ts","../src/compat/array/castArray.ts","../src/compat/math/ceil.ts","../src/compat/array/chunk.ts","../src/array/chunk.ts","../src/compat/array/compact.ts","../src/array/compact.ts","../src/compat/array/concat.ts","../src/compat/predicate/conforms.ts","../src/compat/util/constant.ts","../src/string/constantCase.ts","../src/array/countBy.ts","../src/compat/string/deburr.ts","../src/compat/util/defaultTo.ts","../src/compat/function/defer.ts","../src/compat/function/delay.ts","../src/compat/array/difference.ts","../src/compat/array/differenceBy.ts","../src/compat/array/differenceWith.ts","../src/compat/math/divide.ts","../src/compat/array/drop.ts","../src/array/drop.ts","../src/compat/array/dropRight.ts","../src/array/dropRight.ts","../src/compat/array/dropRightWhile.ts","../src/compat/array/dropWhile.ts","../src/compat/string/endsWith.ts","../src/compat/string/escapeRegExp.ts","../src/string/escapeRegExp.ts","../src/compat/array/every.ts","../src/compat/array/fill.ts","../src/array/fill.ts","../src/compat/array/filter.ts","../src/compat/array/find.ts","../src/compat/array/findIndex.ts","../src/compat/object/findKey.ts","../src/compat/array/findLast.ts","../src/compat/array/findLastIndex.ts","../src/array/flatMap.ts","../src/array/flatMapDeep.ts","../src/array/flattenDeep.ts","../src/compat/array/flattenDeep.ts","../src/compat/array/flattenDepth.ts","../src/compat/function/flip.ts","../src/compat/math/floor.ts","../src/compat/function/flow.ts","../src/compat/function/flowRight.ts","../src/function/flowRight.ts","../src/array/forEachRight.ts","../src/compat/object/fromPairs.ts","../src/array/groupBy.ts","../src/compat/util/gt.ts","../src/compat/util/gte.ts","../src/compat/math/inRange.ts","../src/math/inRange.ts","../src/compat/array/includes.ts","../src/compat/array/indexOf.ts","../src/array/initial.ts","../src/compat/array/intersection.ts","../src/compat/array/intersectionBy.ts","../src/util/invariant.ts","../src/object/invert.ts","../src/compat/object/invertBy.ts","../src/compat/predicate/isArrayBuffer.ts","../src/predicate/isArrayBuffer.ts","../src/compat/predicate/isBoolean.ts","../src/compat/predicate/isBuffer.ts","../src/compat/predicate/isDate.ts","../src/predicate/isDate.ts","../src/compat/predicate/isElement.ts","../src/compat/predicate/isEmpty.ts","../src/predicate/isEqual.ts","../src/compat/predicate/isEqualWith.ts","../src/compat/predicate/isError.ts","../src/predicate/isFile.ts","../src/compat/predicate/isFinite.ts","../src/predicate/isFunction.ts","../src/compat/predicate/isInteger.ts","../src/predicate/isJSON.ts","../src/predicate/isNotNil.ts","../src/predicate/isPromise.ts","../src/compat/predicate/isRegExp.ts","../src/predicate/isRegExp.ts","../src/compat/predicate/isSafeInteger.ts","../src/compat/predicate/isSet.ts","../src/predicate/isSet.ts","../src/array/isSubset.ts","../src/array/isSubsetWith.ts","../src/compat/predicate/isWeakMap.ts","../src/predicate/isWeakMap.ts","../src/compat/predicate/isWeakSet.ts","../src/predicate/isWeakSet.ts","../src/compat/array/join.ts","../src/compat/string/kebabCase.ts","../src/string/kebabCase.ts","../src/array/keyBy.ts","../src/compat/object/keys.ts","../src/compat/array/lastIndexOf.ts","../src/compat/string/lowerCase.ts","../src/string/lowerCase.ts","../src/compat/string/lowerFirst.ts","../src/string/lowerFirst.ts","../src/compat/util/lt.ts","../src/compat/util/lte.ts","../src/compat/array/map.ts","../src/compat/object/mapKeys.ts","../src/compat/object/mapValues.ts","../src/compat/math/max.ts","../src/compat/math/maxBy.ts","../src/array/maxBy.ts","../src/math/meanBy.ts","../src/math/medianBy.ts","../src/function/memoize.ts","../src/compat/object/merge.ts","../src/compat/util/method.ts","../src/compat/util/methodOf.ts","../src/compat/math/min.ts","../src/array/minBy.ts","../src/compat/math/multiply.ts","../src/compat/function/negate.ts","../src/compat/util/now.ts","../src/compat/array/nth.ts","../src/compat/function/nthArg.ts","../src/compat/object/omit.ts","../src/object/omitBy.ts","../src/function/once.ts","../src/compat/string/pad.ts","../src/string/pad.ts","../src/compat/string/padEnd.ts","../src/compat/string/padStart.ts","../src/compat/math/parseInt.ts","../src/array/partition.ts","../src/string/pascalCase.ts","../src/compat/object/pick.ts","../src/compat/object/pickBy.ts","../src/compat/object/propertyOf.ts","../src/compat/array/pull.ts","../src/compat/array/pullAll.ts","../src/compat/array/pullAllBy.ts","../src/array/pullAt.ts","../src/compat/math/random.ts","../src/compat/math/range.ts","../src/compat/math/rangeRight.ts","../src/compat/function/rearg.ts","../src/compat/array/reduce.ts","../src/compat/array/reduceRight.ts","../src/compat/array/remove.ts","../src/array/remove.ts","../src/compat/string/repeat.ts","../src/compat/string/replace.ts","../src/compat/function/rest.ts","../src/function/rest.ts","../src/compat/array/reverse.ts","../src/string/reverseString.ts","../src/compat/math/round.ts","../src/compat/array/sample.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/compat/array/size.ts","../src/compat/array/slice.ts","../src/compat/string/snakeCase.ts","../src/string/snakeCase.ts","../src/compat/array/some.ts","../src/compat/array/sortBy.ts","../src/compat/array/sortedIndex.ts","../src/compat/function/spread.ts","../src/compat/string/startCase.ts","../src/compat/string/startsWith.ts","../src/compat/util/stubArray.ts","../src/compat/util/stubFalse.ts","../src/compat/util/stubObject.ts","../src/compat/util/stubString.ts","../src/compat/util/stubTrue.ts","../src/compat/math/subtract.ts","../src/compat/math/sum.ts","../src/compat/array/tail.ts","../src/array/tail.ts","../src/compat/array/take.ts","../src/array/take.ts","../src/compat/array/takeRight.ts","../src/array/takeRight.ts","../src/compat/array/takeRightWhile.ts","../src/function/negate.ts","../src/array/takeWhile.ts","../src/compat/function/throttle.ts","../src/compat/util/toArray.ts","../src/compat/object/toDefaulted.ts","../src/array/toFilled.ts","../src/compat/util/toLength.ts","../src/compat/_internal/MAX_ARRAY_LENGTH.ts","../src/compat/string/toLower.ts","../src/object/toMerged.ts","../src/compat/util/toPlainObject.ts","../src/compat/util/toSafeInteger.ts","../src/compat/string/toUpper.ts","../src/compat/string/trim.ts","../src/compat/string/trimEnd.ts","../src/compat/string/trimStart.ts","../src/function/unary.ts","../src/compat/string/unescape.ts","../src/compat/array/union.ts","../src/compat/array/uniqBy.ts","../src/compat/array/unzip.ts","../src/array/unzipWith.ts","../src/compat/string/upperCase.ts","../src/string/upperCase.ts","../src/compat/string/upperFirst.ts","../src/string/upperFirst.ts","../src/compat/object/values.ts","../src/compat/object/valuesIn.ts","../src/array/windowed.ts","../src/promise/withTimeout.ts","../src/compat/array/without.ts","../src/array/without.ts","../src/compat/string/words.ts","../src/array/xor.ts","../src/array/union.ts","../src/array/xorBy.ts","../src/array/xorWith.ts","../src/compat/array/zip.ts","../src/array/zipObject.ts","../src/compat/array/zipObjectDeep.ts","../src/array/zipWith.ts"],"sourcesContent":["/**\n * Retrieves elements from an array at the specified indices.\n *\n * This function supports negative indices, which count from the end of the array.\n *\n * @template T\n * @param {readonly T[]} arr - The array to retrieve elements from.\n * @param {number[]} indices - An array of indices specifying the positions of elements to retrieve.\n * @returns {Array<T | undefined>} A new array containing the elements at the specified indices.\n *\n * @example\n * const numbers = [10, 20, 30, 40, 50];\n * const result = at(numbers, [1, 3, 4]);\n * console.log(result); // [20, 40, 50]\n */\nexport function at<T>(arr: readonly T[], indices: number[]): T[] {\n  const result = new Array<T>(indices.length);\n  const length = arr.length;\n\n  for (let i = 0; i < indices.length; i++) {\n    let index = indices[i];\n\n    index = Number.isInteger(index) ? index : Math.trunc(index) || 0;\n\n    if (index < 0) {\n      index += length;\n    }\n\n    result[i] = arr[index];\n  }\n\n  return result;\n}\n","/**\n * Computes the difference between two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements\n * that are present in the first array but not in the second array. It effectively\n * filters out any elements from the first array that also appear in the second array.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\n * from which elements will be compared and filtered.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * Each element in this array will be checked against the first array, and if a match is found,\n * that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the first array but not\n * in the second array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const result = difference(array1, array2);\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\n */\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => !secondSet.has(item));\n}\n","/**\n * Computes the difference between two arrays after mapping their elements through a provided function.\n *\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\n * that are present in the first array but not in the second array, based on the identity calculated\n * by the mapper function.\n *\n * Essentially, it filters out any elements from the first array that, when\n * mapped, match an element in the mapped version of the second array.\n *\n * @template T, U\n * @param {T[]} firstArr - The primary array from which to derive the difference.\n * @param {U[]} secondArr - The array containing elements to be excluded from the first array.\n * @param {(value: T | U) => unknown} mapper - The function to map the elements of both arrays. This function\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\n * mapped identity in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [2, 4];\n * const mapper = item => (typeof item === 'object' ? item.id : item);\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since 2 is present in both arrays after mapping, and is excluded from the result.\n */\nexport function differenceBy<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  mapper: (value: T | U) => unknown\n): T[] {\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\n\n  return firstArr.filter(item => {\n    return !mappedSecondSet.has(mapper(item));\n  });\n}\n","/**\n * Computes the difference between two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a new array containing\n * the elements that are present in the first array but not in the second array. The comparison to determine\n * if elements are equal is made using the provided custom function.\n *\n * @template T, U\n * @param {T[]} firstArr - The array from which to get the difference.\n * @param {U[]} secondArr - The array containing elements to exclude from the first array.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\n * according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the element with id 2 is considered equal to the second array's element and is excluded from the result.\n */\nexport function differenceWith<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  areItemsEqual: (x: T, y: U) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.every(secondItem => {\n      return !areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array from the end and drops elements until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element from the end,\n * and dropping continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRightWhile(array, x => x > 3);\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\n */\nexport function dropRightWhile<T>(\n  arr: readonly T[],\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => boolean\n): T[] {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (!canContinueDropping(arr[i], i, arr)) {\n      return arr.slice(0, i + 1);\n    }\n  }\n\n  return [];\n}\n","/**\n * Removes elements from the beginning of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the start until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T, index: number, arr: T[]) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropWhile(array, x => x < 3);\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\n */\nexport function dropWhile<T>(\n  arr: readonly T[],\n  canContinueDropping: (item: T, index: number, arr: readonly T[]) => boolean\n): T[] {\n  const dropEndIndex = arr.findIndex((item, index, arr) => !canContinueDropping(item, index, arr));\n\n  if (dropEndIndex === -1) {\n    return [];\n  }\n\n  return arr.slice(dropEndIndex);\n}\n","/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\n        recursive(item, currentDepth + 1);\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(arr, 0);\n  return result;\n}\n","/**\n * Returns the intersection of two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements that are\n * present in both arrays. It effectively filters out any elements from the first array that\n * are not found in the second array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @returns {T[]} A new array containing the elements that are present in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => {\n    return secondSet.has(item);\n  });\n}\n","/**\n * Returns the intersection of two arrays based on a mapping function.\n *\n * This function takes two arrays and a mapping function. It returns a new array containing\n * the elements from the first array that, when mapped using the provided function, have matching\n * mapped elements in the second array. It effectively filters out any elements from the first array\n * that do not have corresponding mapped values in the second array.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(item: T | U) => unknown} mapper - A function to map the elements of both arrays for comparison.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const mapper = item => (typeof item === 'object' ? item.id : item);\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2, name: 'amy' }] since only this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionBy<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  mapper: (item: T | U) => unknown\n): T[] {\n  const mappedSecondSet = new Set(secondArr.map(mapper));\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\n}\n","/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2, name: 'amy' }] since this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionWith<T, U>(\n  firstArr: readonly T[],\n  secondArr: readonly U[],\n  areItemsEqual: (x: T, y: U) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.some(secondItem => {\n      return areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {[...T[], T]} arr - The array from which to get the last element.\n * @returns {T} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly [...T[], T]): T;\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly T[]): T | undefined;\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(arr: readonly T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n","/**\n * Removes all specified values from an array.\n *\n * This function changes `arr` in place.\n * If you want to remove values without modifying the original array, use `difference`.\n *\n * @template T, U\n * @param {T[]} arr - The array to modify.\n * @param {unknown[]} valuesToRemove - The values to remove from the array.\n * @returns {T[]} The modified array with the specified values removed.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5, 2, 4];\n * pull(numbers, [2, 4]);\n * console.log(numbers); // [1, 3, 5]\n */\nexport function pull<T>(arr: T[], valuesToRemove: readonly unknown[]): T[] {\n  const valuesSet = new Set(valuesToRemove);\n  let resultIndex = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (valuesSet.has(arr[i])) {\n      continue;\n    }\n\n    // For handling sparse arrays\n    if (!Object.hasOwn(arr, i)) {\n      delete arr[resultIndex++];\n      continue;\n    }\n\n    arr[resultIndex++] = arr[i];\n  }\n\n  arr.length = resultIndex;\n\n  return arr;\n}\n","/**\n * Returns a random element from an array.\n *\n * This function takes an array and returns a single element selected randomly from the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to sample from.\n * @returns {T} A random element from the array.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const randomElement = sample(array);\n * // randomElement will be one of the elements from the array, selected randomly.\n */\nexport function sample<T>(arr: readonly T[]): T {\n  const randomIndex = Math.floor(Math.random() * arr.length);\n  return arr[randomIndex];\n}\n","/**\n * Generate a random number within the given range.\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between 0 (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result1 = random(5); // Returns a random number between 0 and 5.\n * const result2 = random(0); // If the `maximum` is less than or equal to 0, an error is thrown.\n */\nexport function random(maximum: number): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum: number): number;\n\n/**\n * Generate a random number within the given range.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown.\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(minimum: number, maximum?: number): number {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\n  }\n\n  return Math.random() * (maximum - minimum) + minimum;\n}\n","import { random } from './random.ts';\n\n/**\n * Generates a random integer between 0 (inclusive) and the given maximum (exclusive).\n *\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between 0 (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `0`.\n *\n * @example\n * const result = randomInt(5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n */\nexport function randomInt(maximum: number): number;\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(minimum: number, maximum: number): number;\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(minimum: number, maximum?: number): number {\n  return Math.floor(random(minimum, maximum!));\n}\n","/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: readonly T[]): T[] {\n  return Array.from(new Set(arr));\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the mapper function.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr - The array to process.\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\n *\n * @example\n * ```ts\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\n * // [1.2, 2.1, 3.2, 5.7, 7.19]\n * ```\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' },\n * ];\n * uniqBy(array, item => item.category).length\n * // 2\n * ```\n */\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","import { uniqBy } from './uniqBy.ts';\n\n/**\n * Creates an array of unique values, in order, from all given arrays using a provided mapping function to determine equality.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} A new array containing the union of unique elements from `arr1` and `arr2`, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for numbers (modulo comparison)\n * const moduloMapper = (x) => x % 3;\n * unionBy([1, 2, 3], [4, 5, 6], moduloMapper);\n * // Returns [1, 2, 3]\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = (obj) => obj.id;\n * unionBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 2 }, { id: 3 }]\n */\nexport function unionBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  return uniqBy(arr1.concat(arr2), mapper);\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the comparator function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\n *\n * @example\n * ```ts\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\n * // [1.2, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const isUniq = result.every(v => !areItemsEqual(v, item));\n\n    if (isUniq) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","import { uniqWith } from './uniqWith.ts';\n\n/**\n * Creates an array of unique values from two given arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\n * a new array containing only the unique values as determined by the custom equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array of unique values based on the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }];\n * const array2 = [{ id: 2 }, { id: 3 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = unionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\n */\nexport function unionWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areItemsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\n}\n","/**\n * Gathers elements in the same position in an internal array\n * from a grouped array of elements and returns them as a new array.\n *\n * @template T - The type of elements in the nested array.\n * @param {Array<[...T]>} zipped - The nested array to unzip.\n * @returns {Unzip<T>} A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T extends unknown[]>(zipped: ReadonlyArray<[...T]>): Unzip<T> {\n  // For performance reasons, use this implementation instead of\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\n  let maxLen = 0;\n\n  for (let i = 0; i < zipped.length; i++) {\n    if (zipped[i].length > maxLen) {\n      maxLen = zipped[i].length;\n    }\n  }\n\n  const result = new Array(maxLen) as Unzip<T>;\n\n  for (let i = 0; i < maxLen; i++) {\n    result[i] = new Array(zipped.length);\n    for (let j = 0; j < zipped.length; j++) {\n      result[i][j] = zipped[j][i];\n    }\n  }\n\n  return result;\n}\n\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\n","/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {T[]} arr1 - The first array to zip.\n * @returns {Array<[T]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = zip(arr1);\n * // result will be [[1], [2], [3]]\n */\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @returns {Array<[T, U]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n */\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @returns {Array<[T, U, V]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T, U, V, W\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} arr2 - The second array to zip.\n * @param {V[]} arr3 - The third array to zip.\n * @param {W[]} arr4 - The fourth array to zip.\n * @returns {Array<[T, U, V, W]>} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const arr4 = [null, null, null];\n * const result = zip(arr1, arr2, arr3, arr4);\n * // result will be [[1, 'a', true, null], [2, 'b', false, null], [3, 'c', undefined, null]]\n */\nexport function zip<T, U, V, W>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[]\n): Array<[T, U, V, W]>;\n\n/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @template T\n * @param {...Array<readonly T[]>} arrs - The arrays to zip together.\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const arr3 = [true, false];\n * const result = zip(arr1, arr2, arr3);\n * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\n  // For performance reasons, use this implementation instead of\n  // const rowCount = Math.max(...arrs.map(x => x.length));\n  let rowCount = 0;\n\n  for (let i = 0; i < arrs.length; i++) {\n    if (arrs[i].length > rowCount) {\n      rowCount = arrs[i].length;\n    }\n  }\n  const columnCount = arrs.length;\n  const result = Array(rowCount);\n\n  for (let i = 0; i < rowCount; ++i) {\n    const row = Array(columnCount);\n    for (let j = 0; j < columnCount; ++j) {\n      row[j] = arrs[j][i];\n    }\n    result[i] = row;\n  }\n  return result;\n}\n","/**\n * An error class representing an aborted operation.\n * @augments Error\n */\nexport class AbortError extends Error {\n  constructor(message = 'The operation was aborted') {\n    super(message);\n    this.name = 'AbortError';\n  }\n}\n","/**\n * An error class representing an timeout operation.\n * @augments Error\n */\nexport class TimeoutError extends Error {\n  constructor(message = 'The operation was timed out') {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n","/**\n * Creates a function that only executes starting from the `n`-th call.\n * The provided function will be invoked starting from the `n`-th call.\n *\n * This is particularly useful for scenarios involving events or asynchronous operations\n * where an action should occur only after a certain number of invocations.\n *\n * @template F - The type of the function to be invoked.\n * @param {number} n - The number of calls required for `func` to execute.\n * @param {F} func - The function to be invoked.\n * @returns {(...args: Parameters<F>) => ReturnType<F> | undefined} - A new function that:\n * - Tracks the number of calls.\n * - Invokes `func` starting from the `n`-th call.\n * - Returns `undefined` if fewer than `n` calls have been made.\n * @throws {Error} - Throws an error if `n` is negative.\n * @example\n *\n * const afterFn = after(3, () => {\n *  console.log(\"called\")\n * });\n *\n * // Will not log anything.\n * afterFn()\n * // Will not log anything.\n * afterFn()\n * // Will log 'called'.\n * afterFn()\n */\n\nexport function after<F extends (...args: any[]) => any>(\n  n: number,\n  func: F\n): (...args: Parameters<F>) => ReturnType<F> | undefined {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new Error(`n must be a non-negative integer.`);\n  }\n\n  let counter = 0;\n  return (...args: Parameters<F>) => {\n    if (++counter >= n) {\n      return func(...args);\n    }\n    return undefined;\n  };\n}\n","/**\n * Creates a function that invokes func, with up to n arguments, ignoring any additional arguments.\n *\n * @template F - The type of the function.\n * @param {F} func - The function to cap arguments for.\n * @param {number} n - The arity cap.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new capped function.\n *\n * @example\n * function fn(a: number, b: number, c: number) {\n *   return Array.from(arguments);\n * }\n *\n * ary(fn, 0)(1, 2, 3) // []\n * ary(fn, 1)(1, 2, 3) // [1]\n * ary(fn, 2)(1, 2, 3) // [1, 2]\n * ary(fn, 3)(1, 2, 3) // [1, 2, 3]\n */\nexport function ary<F extends (...args: any[]) => any>(func: F, n: number): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...args: Parameters<F>) {\n    return func.apply(this, args.slice(0, n));\n  };\n}\n","interface DebounceOptions {\n  /**\n   * An optional AbortSignal to cancel the debounced function.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * An optional array specifying whether the function should be invoked on the leading edge, trailing edge, or both.\n   * If `edges` includes \"leading\", the function will be invoked at the start of the delay period.\n   * If `edges` includes \"trailing\", the function will be invoked at the end of the delay period.\n   * If both \"leading\" and \"trailing\" are included, the function will be invoked at both the start and end of the delay period.\n   * @default [\"trailing\"]\n   */\n  edges?: Array<'leading' | 'trailing'>;\n}\n\nexport interface DebouncedFunction<F extends (...args: any[]) => void> {\n  (...args: Parameters<F>): void;\n\n  /**\n   * Schedules the execution of the debounced function after the specified debounce delay.\n   * This method resets any existing timer, ensuring that the function is only invoked\n   * after the delay has elapsed since the last call to the debounced function.\n   * It is typically called internally whenever the debounced function is invoked.\n   *\n   * @returns {void}\n   */\n  schedule: () => void;\n\n  /**\n   * Cancels any pending execution of the debounced function.\n   * This method clears the active timer and resets any stored context or arguments.\n   */\n  cancel: () => void;\n\n  /**\n   * Immediately invokes the debounced function if there is a pending execution.\n   * This method also cancels the current timer, ensuring that the function executes right away.\n   */\n  flush: () => void;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => void>(\n  func: F,\n  debounceMs: number,\n  { signal, edges }: DebounceOptions = {}\n): DebouncedFunction<F> {\n  let pendingThis: any = undefined;\n  let pendingArgs: Parameters<F> | null = null;\n\n  const leading = edges != null && edges.includes('leading');\n  const trailing = edges == null || edges.includes('trailing');\n\n  const invoke = () => {\n    if (pendingArgs !== null) {\n      func.apply(pendingThis, pendingArgs);\n      pendingThis = undefined;\n      pendingArgs = null;\n    }\n  };\n\n  const onTimerEnd = () => {\n    if (trailing) {\n      invoke();\n    }\n\n    cancel();\n  };\n\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const schedule = () => {\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n\n      onTimerEnd();\n    }, debounceMs);\n  };\n\n  const cancelTimer = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  const cancel = () => {\n    cancelTimer();\n    pendingThis = undefined;\n    pendingArgs = null;\n  };\n\n  const flush = () => {\n    cancelTimer();\n    invoke();\n  };\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    if (signal?.aborted) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    pendingThis = this;\n    pendingArgs = args;\n\n    const isFirstCall = timeoutId == null;\n\n    schedule();\n\n    if (leading && isFirstCall) {\n      invoke();\n    }\n  };\n\n  debounced.schedule = schedule;\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n\n  signal?.addEventListener('abort', cancel, { once: true });\n\n  return debounced;\n}\n","/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {() => R} f The function to invoke.\n * @returns {() => R} Returns the new composite function.\n *\n * @example\n * function noArgFunc() {\n *  return 42;\n * }\n *\n * const combined = flow(noArgFunc);\n * console.log(combined()); // 42\n */\nexport function flow<R>(f: () => R): () => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R} f1 The function to invoke.\n * @returns {(...args: A) => R} Returns the new composite function.\n *\n * @example\n * function oneArgFunc(a: number) {\n *   return a * 2;\n * }\n *\n * const combined = flow(oneArgFunc);\n * console.log(combined(5)); // 10\n */\nexport function flow<A extends any[], R>(f1: (...args: A) => R): (...args: A) => R;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @returns {(...args: A) => R2} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @returns {(...args: A) => R3} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n *\n * const combined = flow(add, square, double);\n * console.log(combined(1, 2)); // 18\n */\nexport function flow<A extends any[], R1, R2, R3>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3\n): (...args: A) => R3;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @returns {(...args: A) => R4} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n *\n * const combined = flow(add, square, double, toStr);\n * console.log(combined(1, 2)); // '18'\n */\nexport function flow<A extends any[], R1, R2, R3, R4>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4\n): (...args: A) => R4;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {(...args: A) => R1} f1 The function to invoke.\n * @param {(a: R1) => R2} f2 The function to invoke.\n * @param {(a: R2) => R3} f3 The function to invoke.\n * @param {(a: R3) => R4} f4 The function to invoke.\n * @param {(a: R4) => R5} f5 The function to invoke.\n * @returns {(...args: A) => R5} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n * const double = (n: number) => n * 2;\n * const toStr = (n: number) => n.toString();\n * const split = (s: string) => s.split('');\n *\n * const combined = flow(add, square, double, toStr, split);\n * console.log(combined(1, 2)); // ['1', '8']\n */\nexport function flow<A extends any[], R1, R2, R3, R4, R5>(\n  f1: (...args: A) => R1,\n  f2: (a: R1) => R2,\n  f3: (a: R2) => R3,\n  f4: (a: R3) => R4,\n  f5: (a: R4) => R5\n): (...args: A) => R5;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any;\n/**\n * Creates a new function that executes the given functions in sequence. The return value of the previous function is passed as an argument to the next function.\n *\n * The `this` context of the returned function is also passed to the functions provided as parameters.\n *\n * @param {Array<(...args: any[]) => any>} funcs The functions to invoke.\n * @returns {(...args: any[]) => any} Returns the new composite function.\n *\n * @example\n * const add = (x: number, y: number) => x + y;\n * const square = (n: number) => n * n;\n *\n * const combined = flow(add, square);\n * console.log(combined(1, 2)); // 9\n */\nexport function flow(...funcs: Array<(...args: any[]) => any>): (...args: any[]) => any {\n  return function (this: any, ...args: any[]) {\n    let result = funcs.length ? funcs[0].apply(this, args) : args[0];\n\n    for (let i = 1; i < funcs.length; i++) {\n      result = funcs[i].call(this, result);\n    }\n\n    return result;\n  };\n}\n","/**\n * Returns the input value unchanged.\n *\n * @template T - The type of the input value.\n * @param {T} x - The value to be returned.\n * @returns {T} The input value.\n *\n * @example\n * // Returns 5\n * identity(5);\n *\n * @example\n * // Returns 'hello'\n * identity('hello');\n *\n * @example\n * // Returns { key: 'value' }\n * identity({ key: 'value' });\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\nexport function noop(): void {}\n","type Placeholder = typeof partialPlaceholder;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(): R} A new function that takes no arguments and returns the result of the original function.\n *\n * @example\n * const addOne = (x: number) => x + 1;\n * const addOneToFive = partial(addOne, 5);\n * console.log(addOneToFive()); // => 6\n */\nexport function partial<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number) => x * y;\n * const double = partial(multiply, 2);\n * console.log(double(5)); // => 10\n */\nexport function partial<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2): R} func The function to partially apply.\n * @param {Placeholder} placeholder The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg1: T1): R} A new function that takes the first argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithHello = partial(greet, partial.placeholder, 'John');\n * console.log(greetWithHello('Hello')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, R>(\n  func: (arg1: T1, arg2: T2) => R,\n  placeholder: Placeholder,\n  arg2: T2\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2, arg3: T3): R} A new function that takes the second and third arguments and returns the result of the original function.\n *\n * @example\n * const sumThree = (a: number, b: number, c: number) => a + b + c;\n * const addFive = partial(sumThree, 5);\n * console.log(addFive(3, 2)); // => 10\n */\nexport function partial<T1, T2, T3, R>(func: (arg1: T1, arg2: T2, arg3: T3) => R, arg1: T1): (arg2: T2, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, partial.placeholder, 'John');\n * console.log(greetWithPlaceholder('Hello')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: Placeholder,\n  arg2: T2\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number) => x * y * z;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2);\n * console.log(multiplyWithPlaceholders(3, 4)); // => 24\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder);\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3): R} func The function to partially apply.\n * @param {Placeholder} arg1 The first argument to apply.\n * @param {T2} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string) => `${greeting}, ${name}!`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder);\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  plc1: Placeholder,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const double = partial(multiply, 2);\n * console.log(double(5, 4, 3)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1\n): (arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholders(4, 5)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(arg3: T3, arg4: T4): R} A new function that takes the third and fourth arguments and returns the result of the original function.\n *\n * @example\n * const sumFour = (a: number, b: number, c: number, d: number) => a + b + c + d;\n * const addOneAndTwo = partial(sumFour, 1, 2);\n * console.log(addOneAndTwo(3, 4)); // => 10\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2\n): (arg3: T3, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg2: T2, arg4: T4): R} A new function that takes the second and fourth arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithPlaceholder = partial(greet, 'Hello', partial.placeholder, '!');\n * console.log(greetWithPlaceholder('John')); // => 'Hello, John!'\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholder = partial(multiply, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholder(4)); // => 24\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg3: T3): R} A new function that takes the first and third arguments and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1, arg2: T2): R} A new function that takes the first and second arguments and returns the result of the original function.\n *\n * @example\n * const multiply = (x: number, y: number, z: number, w: number) => x * y * z * w;\n * const multiplyWithPlaceholders = partial(multiply, partial.placeholder, partial.placeholder, 2, 3);\n * console.log(multiplyWithPlaceholders(4, 5)); // => 120\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(arg4: T4): R} A new function that takes the fourth argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): (arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg3: T3): R} A new function that takes the third argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg3: T3) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg2: T2): R} A new function that takes the second argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg2: T2) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, arg3: T3, arg4: T4): R} func The function to partially apply.\n * @param {Placeholder} arg1 The placeholder for the first argument.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(arg1: T1): R} A new function that takes the first argument and returns the result of the original function.\n */\nexport function partial<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: Placeholder,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template R The return type of the function.\n * @param {function(...args: TS): R} func The function to partially apply.\n * @returns {function(...args: TS): R} A new function that takes the same arguments as the original function.\n *\n * @example\n * const add = (...numbers: number[]) => numbers.reduce((sum, n) => sum + n, 0);\n * const addFive = partial(add, 5);\n * console.log(addFive(1, 2, 3)); // => 11\n */\nexport function partial<TS extends any[], R>(func: (...args: TS) => R): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, ...args: TS): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, ...names: string[]) => `${greeting}, ${names.join(', ')}!`;\n * const greetHello = partial(greet, 'Hello');\n * console.log(greetHello('Alice', 'Bob')); // => 'Hello, Alice, Bob!'\n */\nexport function partial<TS extends any[], T1, R>(func: (arg1: T1, ...args: TS) => R, arg1: T1): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {function(arg1: T1, arg2: T2, ...args: TS): R} func The function to partially apply.\n * @param {T1} arg1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', '!');\n * console.log(greetWithHello('John')); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, R>(\n  func: (arg1: T1, arg2: T2, ...args: TS) => R,\n  t1: T1,\n  arg2: T2\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {function(t1: T1, arg2: T2, arg3: T3, ...args: TS): R} func The function to partially apply.\n * @param {T1} t1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', 'John', '!');\n * console.log(greetWithHello()); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, T3, R>(\n  func: (t1: T1, arg2: T2, arg3: T3, ...args: TS) => R,\n  t1: T1,\n  arg2: T2,\n  arg3: T3\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template TS The types of the arguments.\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {function(t1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: TS): R} func The function to partially apply.\n * @param {T1} t1 The first argument to apply.\n * @param {T2} arg2 The second argument to apply.\n * @param {T3} arg3 The third argument to apply.\n * @param {T4} arg4 The fourth argument to apply.\n * @returns {function(...args: TS): R} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const greet = (greeting: string, name: string, punctuation: string) => `${greeting}, ${name}${punctuation}`;\n * const greetWithHello = partial(greet, 'Hello', 'John', '!');\n * console.log(greetWithHello()); // => 'Hello, John!'\n */\nexport function partial<TS extends any[], T1, T2, T3, T4, R>(\n  func: (t1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: TS) => R,\n  t1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (...args: TS) => R;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply.\n * @param {...any[]} partialArgs The arguments to be partially applied.\n * @returns {function(...args: any[]): ReturnType<F>} A new function that takes the remaining arguments and returns the result of the original function.\n *\n * @example\n * const add = (...numbers: number[]) => numbers.reduce((sum, n) => sum + n, 0);\n * const addFive = partial(add, 5);\n * console.log(addFive(1, 2, 3)); // => 11\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F>;\n\n/**\n * Creates a function that invokes `func` with `partialArgs` prepended to the arguments it receives. This method is like `bind` except it does not alter the `this` binding.\n *\n * The partial.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const sayHelloTo = partial(greet, 'hello');\n * sayHelloTo('fred');\n * // => 'hello fred'\n *\n * // Partially applied with placeholders.\n * const greetFred = partial(greet, partial.placeholder, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n */\nexport function partial<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    let startIndex = 0;\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === partial.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    return func.apply(this, args);\n  } as any as F;\n}\n\nconst partialPlaceholder: unique symbol = Symbol('partial.placeholder');\npartial.placeholder = partialPlaceholder;\n","type Placeholder = typeof partialRightPlaceholder;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template R The return type of the function.\n * @param {() => R} func The function to invoke.\n * @returns {() => R} Returns the new function.\n * @example\n * const getValue = () => 42;\n * const getValueFunc = partialRight(getValue);\n * console.log(getValueFunc()); // => 42\n */\nexport function partialRight<R>(func: () => R): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const addOne = (num: number) => num + 1;\n * const addOneFunc = partialRight(addOne, 1);\n * console.log(addOneFunc()); // => 2\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const multiplyBy = (factor: number) => (num: number) => num * factor;\n * const double = partialRight(multiplyBy(2));\n * console.log(double(5)); // => 10\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template R The return type of the function.\n * @param {(arg1: T1) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const greet = (name: string) => `Hello, ${name}!`;\n * const greetJohn = partialRight(greet, 'John');\n * console.log(greetJohn()); // => 'Hello, John!'\n */\nexport function partialRight<T1, R>(func: (arg1: T1) => R, arg1: T1): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const subtract = (a: number, b: number) => a - b;\n * const subtractFive = partialRight(subtract);\n * console.log(subtractFive(10, 5)); // => 5\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R): (arg1: T1, arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @returns {(arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const concat = (a: string, b: string) => a + b;\n * const concatWithHello = partialRight(concat, 'Hello', partialRight.placeholder);\n * console.log(concatWithHello(' World!')); // => 'Hello World!'\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1, arg2: Placeholder): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const divide = (a: number, b: number) => a / b;\n * const divideByTwo = partialRight(divide, 2);\n * console.log(divideByTwo(10)); // => 5\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg2: T2): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const multiply = (a: number, b: number) => a * b;\n * const multiplyByThreeAndFour = partialRight(multiply, 3, 4);\n * console.log(multiplyByThreeAndFour()); // => 12\n */\nexport function partialRight<T1, T2, R>(func: (arg1: T1, arg2: T2) => R, arg1: T1, arg2: T2): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const sumThree = (a: number, b: number, c: number) => a + b + c;\n * const sumWithFive = partialRight(sumThree);\n * console.log(sumWithFive(1, 2, 5)); // => 8\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R\n): (arg1: T1, arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg2: T2, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const formatDate = (day: number, month: number, year: number) => `${day}/${month}/${year}`;\n * const formatDateWithDay = partialRight(formatDate, 1, partialRight.placeholder, partialRight.placeholder);\n * console.log(formatDateWithDay(12, 2023)); // => '1/12/2023'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder\n): (arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg1: T1, arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const createUser = (name: string, age: number, country: string) => `${name}, ${age} years old from ${country}`;\n * const createUserFromUSA = partialRight(createUser, 'USA', partialRight.placeholder);\n * console.log(createUserFromUSA('John', 30)); // => 'John, 30 years old from USA'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg2: T2,\n  arg3: Placeholder\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @returns {(arg3: T3) => R} Returns the new partially applied function.\n * @example\n * const logMessage = (level: string, message: string, timestamp: string) => `[${level}] ${message} at ${timestamp}`;\n * const logError = partialRight(logMessage, 'ERROR', '2023-10-01');\n * console.log(logError('Something went wrong!')); // => '[ERROR] Something went wrong! at 2023-10-01'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder\n): (arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const calculateArea = (length: number, width: number) => length * width;\n * const calculateAreaWithWidth = partialRight(calculateArea, 5);\n * console.log(calculateAreaWithWidth(10)); // => 50\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg3: T3\n): (arg1: T1, arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg2: T2) => R} Returns the new partially applied function.\n * @example\n * const formatCurrency = (amount: number, currency: string) => `${amount} ${currency}`;\n * const formatUSD = partialRight(formatCurrency, 100, partialRight.placeholder);\n * console.log(formatUSD('USD')); // => '100 USD'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3\n): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns the new partially applied function.\n * @example\n * const createProfile = (name: string, age: number, country: string) => `${name}, ${age} from ${country}`;\n * const createProfileFromCanada = partialRight(createProfile, 'Canada', 'John');\n * console.log(createProfileFromCanada(30)); // => 'John, 30 from Canada'\n */\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg2: T2,\n  arg3: T3\n): (arg1: T1) => R;\n\nexport function partialRight<T1, T2, T3, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): () => R;\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @returns {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} Returns a new function that takes four arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R\n): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg2: T2, arg3: T3, arg4: T4) => R} Returns a new function that takes the second, third, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg2: T2, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg3: T3, arg4: T4) => R} Returns a new function that takes the first, third, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg1: T1, arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg3: T3, arg4: T4) => R} Returns a new function that takes the third and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: Placeholder\n): (arg3: T3, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg2: T2, arg4: T4) => R} Returns a new function that takes the first, second, and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg3: T3,\n  arg4: Placeholder\n): (arg1: T1, arg2: T2, arg4: T4) => R;\n\n/**\n * Creates a function that invokes `func` with the first argument, a placeholder for the second argument,\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg2: T2, arg4: T4) => R} Returns a new function that takes the second and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: Placeholder\n): (arg2: T2, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg1: T1, arg4: T4) => R} Returns a new function that takes the first and fourth arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: Placeholder\n): (arg1: T1, arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {Placeholder} arg4 The placeholder for the fourth argument.\n * @returns {(arg4: T4) => R} Returns a new function that takes the fourth argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: Placeholder\n): (arg4: T4) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2, arg3: T3) => R} Returns a new function that takes the first, second, and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg4: T4\n): (arg1: T1, arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg2: T2, arg3: T3) => R} Returns a new function that takes the second and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: Placeholder,\n  arg4: T4\n): (arg2: T2, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg3: T3) => R} Returns a new function that takes the first and third arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg1: T1, arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {Placeholder} arg3 The placeholder for the third argument.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg3: T3) => R} Returns a new function that takes the third argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: Placeholder,\n  arg4: T4\n): (arg3: T3) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1, arg2: T2) => R} Returns a new function that takes the first and second arguments.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1, arg2: T2) => R;\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {Placeholder} arg2 The placeholder for the second argument.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg2: T2) => R} Returns a new function that takes the second argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: Placeholder,\n  arg3: T3,\n  arg4: T4\n): (arg2: T2) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {(arg1: T1) => R} Returns a new function that takes the first argument.\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (arg1: T1) => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template T1 The type of the first argument.\n * @template T2 The type of the second argument.\n * @template T3 The type of the third argument.\n * @template T4 The type of the fourth argument.\n * @template R The return type of the function.\n * @param {(arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R} func The function to partially apply arguments to.\n * @param {T1} arg1 The first argument to be partially applied.\n * @param {T2} arg2 The second argument to be partially applied.\n * @param {T3} arg3 The third argument to be partially applied.\n * @param {T4} arg4 The fourth argument to be partially applied.\n * @returns {() => R} Returns the new partially applied function.\n * @example\n * const concatenate = (a: string, b: string, c: string, d: string) => a + b + c + d;\n * const concatenateHelloWorld = partialRight(concatenate, 'Hello', ' ', 'World', '!');\n * console.log(concatenateHelloWorld()); // => 'Hello World!'\n */\nexport function partialRight<T1, T2, T3, T4, R>(\n  func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): () => R;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {...any[]} args The arguments to be partially applied.\n * @returns {function(...args: any[]): ReturnType<F>} Returns the new partially applied function.\n * @example\n * const log = (...messages: string[]) => console.log(...messages);\n * const logError = partialRight(log, 'Error:');\n * logError('Something went wrong!'); // => 'Error: Something went wrong!'\n */\nexport function partialRight(func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\n\n/**\n * This method is like `partial` except that partially applied arguments are appended to the arguments it receives.\n *\n * The partialRight.placeholder value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of partially applied functions.\n *\n * @template F The type of the function to partially apply.\n * @param {F} func The function to partially apply arguments to.\n * @param {any[]} partialArgs The arguments to be partially applied.\n * @returns {(...args: any[]) => ReturnType<F>} Returns the new partially applied function.\n *\n * @example\n * function greet(greeting, name) {\n *   return greeting + ' ' + name;\n * }\n *\n * const greetFred = partialRight(greet, 'fred');\n * greetFred('hi');\n * // => 'hi fred'\n *\n * // Partially applied with placeholders.\n * const sayHelloTo = partialRight(greet, 'hello', partialRight.placeholder);\n * sayHelloTo('fred');\n * // => 'hello fred'\n */\nexport function partialRight<F extends (...args: any[]) => any>(\n  func: F,\n  ...partialArgs: any[]\n): (...args: any[]) => ReturnType<F> {\n  return function (this: any, ...providedArgs: any[]) {\n    const placeholderLength = partialArgs.filter(arg => arg === partialRightPlaceholder).length;\n    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n    const args: any[] = [];\n\n    let providedIndex = 0;\n    for (let i = 0; i < rangeLength; i++) {\n      args.push(providedArgs[providedIndex++]);\n    }\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === partialRight.placeholder) {\n        args.push(providedArgs[providedIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n    return func.apply(this, args);\n  } as any as F;\n}\n\nconst partialRightPlaceholder: unique symbol = Symbol('partialRight.placeholder');\npartialRight.placeholder = partialRightPlaceholder;\n","import { AbortError } from '../error/AbortError.ts';\n\ninterface DelayOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n *\n * This function returns a Promise that resolves after the specified delay, allowing you to use it\n * with async/await to pause execution.\n *\n * @param {number} ms - The number of milliseconds to delay.\n * @param {DelayOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the delay.\n * @returns {Promise<void>} A Promise that resolves after the specified delay.\n *\n * @example\n * async function foo() {\n *   console.log('Start');\n *   await delay(1000); // Delays execution for 1 second\n *   console.log('End');\n * }\n *\n * foo();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const { signal } = controller;\n *\n * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms\n * try {\n *   await delay(100, { signal });\n *  } catch (error) {\n *   console.error(error); // Will log 'AbortError'\n *  }\n * }\n */\nexport function delay(ms: number, { signal }: DelayOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const abortError = () => {\n      reject(new AbortError());\n    };\n\n    const abortHandler = () => {\n      clearTimeout(timeoutId);\n      abortError();\n    };\n\n    if (signal?.aborted) {\n      return abortError();\n    }\n\n    const timeoutId = setTimeout(() => {\n      signal?.removeEventListener('abort', abortHandler);\n      resolve();\n    }, ms);\n\n    signal?.addEventListener('abort', abortHandler, { once: true });\n  });\n}\n","/**\n * A counting semaphore for async functions that manages available permits.\n * Semaphores are mainly used to limit the number of concurrent async tasks.\n *\n * Each `acquire` operation takes a permit or waits until one is available.\n * Each `release` operation adds a permit, potentially allowing a waiting task to proceed.\n *\n * The semaphore ensures fairness by maintaining a FIFO (First In, First Out) order for acquirers.\n *\n * @example\n * const sema = new Semaphore(2);\n *\n * async function task() {\n *   await sema.acquire();\n *   try {\n *     // This code can only be executed by two tasks at the same time\n *   } finally {\n *     sema.release();\n *   }\n * }\n *\n * task();\n * task();\n * task(); // This task will wait until one of the previous tasks releases the semaphore.\n */\nexport class Semaphore {\n  /**\n   * The maximum number of concurrent operations allowed.\n   * @type {number}\n   */\n  public capacity: number;\n\n  /**\n   * The number of available permits.\n   * @type {number}\n   */\n  public available: number;\n  private deferredTasks: Array<() => void> = [];\n\n  /**\n   * Creates an instance of Semaphore.\n   * @param {number} capacity - The maximum number of concurrent operations allowed.\n   *\n   * @example\n   * const sema = new Semaphore(3); // Allows up to 3 concurrent operations.\n   */\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.available = capacity;\n  }\n\n  /**\n   * Acquires a semaphore, blocking if necessary until one is available.\n   * @returns {Promise<void>} A promise that resolves when the semaphore is acquired.\n   *\n   * @example\n   * const sema = new Semaphore(1);\n   *\n   * async function criticalSection() {\n   *   await sema.acquire();\n   *   try {\n   *     // This code section cannot be executed simultaneously\n   *   } finally {\n   *     sema.release();\n   *   }\n   * }\n   */\n  async acquire(): Promise<void> {\n    if (this.available > 0) {\n      this.available--;\n      return;\n    }\n\n    return new Promise<void>(resolve => {\n      this.deferredTasks.push(resolve);\n    });\n  }\n\n  /**\n   * Releases a semaphore, allowing one more operation to proceed.\n   *\n   * @example\n   * const sema = new Semaphore(1);\n   *\n   * async function task() {\n   *   await sema.acquire();\n   *   try {\n   *     // This code can only be executed by two tasks at the same time\n   *   } finally {\n   *     sema.release(); // Allows another waiting task to proceed.\n   *   }\n   * }\n   */\n  release(): void {\n    const deferredTask = this.deferredTasks.shift();\n\n    if (deferredTask != null) {\n      deferredTask();\n      return;\n    }\n\n    if (this.available < this.capacity) {\n      this.available++;\n    }\n  }\n}\n","import { delay } from './delay.ts';\nimport { TimeoutError } from '../error/TimeoutError.ts';\n\n/**\n * Returns a promise that rejects with a `TimeoutError` after a specified delay.\n *\n * @param {number} ms - The delay duration in milliseconds.\n * @returns {Promise<never>} A promise that rejects with a `TimeoutError` after the specified delay.\n * @throws {TimeoutError} Throws a `TimeoutError` after the specified delay.\n *\n * @example\n * try {\n *   await timeout(1000); // Timeout exception after 1 second\n * } catch (error) {\n *   console.error(error); // Will log 'The operation was timed out'\n * }\n */\nexport async function timeout(ms: number): Promise<never> {\n  await delay(ms);\n  throw new TimeoutError();\n}\n","import { delay as delayToolkit } from '../promise';\n\ninterface RetryOptions {\n  /**\n   * The number of milliseconds to interval delay.\n   * @default 0\n   */\n  delay?: number;\n\n  /**\n   * The number of retries to attempt.\n   * @default Number.POSITIVE_INFINITY\n   */\n  retries?: number;\n\n  /**\n   * An AbortSignal to cancel the retry operation.\n   */\n  signal?: AbortSignal;\n}\n\nconst DEFAULT_DELAY = 0;\nconst DEFAULT_RETRIES = Number.POSITIVE_INFINITY;\n\n/**\n * Retries a function that returns a promise until it resolves successfully.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n *\n * @example\n * // Basic usage with default retry options\n * retry(() => fetchData()).then(data => console.log(data));\n */\nexport async function retry<T>(func: () => Promise<T>): Promise<T>;\n\n/**\n * Retries a function that returns a promise a specified number of times.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry. It should return a promise.\n * @param {number} retries - The number of retries to attempt. Default is Infinity.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n *\n * @example\n * // Retry a function up to 3 times\n * retry(() => fetchData(), 3).then(data => console.log(data));\n */\nexport async function retry<T>(func: () => Promise<T>, retries: number): Promise<T>;\n\n/**\n * Retries a function that returns a promise with specified options.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry. It should return a promise.\n * @param {RetryOptions} options - Options to configure the retry behavior.\n * @param {number} [options.delay=0] - The number of milliseconds to wait between retries.\n * @param {number} [options.retries=Infinity] - The number of retries to attempt.\n * @param {AbortSignal} [options.signal] - An AbortSignal to cancel the retry operation.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n *\n * @example\n * // Retry a function with a delay of 1000ms between attempts\n * retry(() => fetchData(), { delay: 1000, times: 5 }).then(data => console.log(data));\n */\nexport async function retry<T>(func: () => Promise<T>, options: RetryOptions): Promise<T>;\n\n/**\n * Retries a function that returns a promise with specified options.\n *\n * @template T\n * @param {() => Promise<T>} func - The function to retry. It should return a promise.\n * @param {number | RetryOptions} [_options] - Either the number of retries or an options object.\n * @returns {Promise<T>} A promise that resolves with the value of the successful function call.\n */\nexport async function retry<T>(func: () => Promise<T>, _options?: number | RetryOptions): Promise<T> {\n  let delay: number;\n  let retries: number;\n  let signal: AbortSignal | undefined;\n\n  if (typeof _options === 'number') {\n    delay = DEFAULT_DELAY;\n    retries = _options;\n    signal = undefined;\n  } else {\n    delay = _options?.delay ?? DEFAULT_DELAY;\n    retries = _options?.retries ?? DEFAULT_RETRIES;\n    signal = _options?.signal;\n  }\n\n  let error;\n\n  for (let i = 0; i < retries; i++) {\n    if (signal?.aborted) {\n      throw error ?? new Error(`The retry operation was aborted due to an abort signal.`);\n    }\n\n    try {\n      return await func();\n    } catch (err) {\n      error = err;\n      await delayToolkit(delay);\n    }\n  }\n\n  throw error;\n}\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the average of an array of numbers.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the average.\n * @returns {number} The average of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = mean(numbers);\n * // result will be 3\n */\nexport function mean(nums: readonly number[]): number {\n  return sum(nums) / nums.length;\n}\n","/**\n * Calculates the sum of an array of numbers.\n *\n * This function takes an array of numbers and returns the sum of all the elements in the array.\n *\n * @param {number[]} nums - An array of numbers to be summed.\n * @returns {number} The sum of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = sum(numbers);\n * // result will be 15\n */\nexport function sum(nums: readonly number[]): number {\n  let result = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    result += nums[i];\n  }\n\n  return result;\n}\n","/**\n * Calculates the median of an array of numbers.\n *\n * The median is the middle value of a sorted array.\n * If the array has an odd number of elements, the median is the middle value.\n * If the array has an even number of elements, it returns the average of the two middle values.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the median.\n * @returns {number} The median of all the numbers in the array.\n *\n * @example\n * const arrayWithOddNumberOfElements = [1, 2, 3, 4, 5];\n * const result = median(arrayWithOddNumberOfElements);\n * // result will be 3\n *\n * @example\n * const arrayWithEvenNumberOfElements = [1, 2, 3, 4];\n * const result = median(arrayWithEvenNumberOfElements);\n * // result will be 2.5\n */\nexport function median(nums: readonly number[]): number {\n  if (nums.length === 0) {\n    return NaN;\n  }\n\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const middleIndex = Math.floor(sorted.length / 2);\n\n  if (sorted.length % 2 === 0) {\n    return (sorted[middleIndex - 1] + sorted[middleIndex]) / 2;\n  } else {\n    return sorted[middleIndex];\n  }\n}\n","/**\n * Returns an array of numbers from `0` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `0` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n */\nexport function range(end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with a step of `1`.\n *\n * @example\n * // Returns [1, 2, 3]\n * range(1, 4);\n */\nexport function range(start: number, end: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n *\n * @example\n * // Returns [0, 5, 10, 15]\n * range(0, 20, 5);\n */\nexport function range(start: number, end: number, step: number): number[];\n\n/**\n * Returns an array of numbers from `start` (inclusive) to `end` (exclusive), incrementing by `step`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} end - The end number of the range (exclusive).\n * @param {number} step - The step value for the range.\n * @returns {number[]} An array of numbers from `start` (inclusive) to `end` (exclusive) with the specified `step`.\n * @throws {Error} Throws an error if the step value is not a non-zero integer.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n */\nexport function range(start: number, end?: number, step = 1): number[] {\n  if (end == null) {\n    end = start;\n    start = 0;\n  }\n\n  if (!Number.isInteger(step) || step === 0) {\n    throw new Error(`The step value must be a non-zero integer.`);\n  }\n\n  const length = Math.max(Math.ceil((end - start) / step), 0);\n  const result = new Array<number>(length);\n\n  for (let i = 0; i < length; i++) {\n    result[i] = start + i * step;\n  }\n\n  return result;\n}\n","/**\n * Checks whether a value is a JavaScript primitive.\n * JavaScript primitives include null, undefined, strings, numbers, booleans, symbols, and bigints.\n *\n * @param {unknown} value The value to check.\n * @returns {value is\n *     null\n *   | undefined\n *   | string\n *   | number\n *   | boolean\n *   | symbol\n *   | bigint} Returns true if `value` is a primitive, false otherwise.\n *\n * @example\n * isPrimitive(null); // true\n * isPrimitive(undefined); // true\n * isPrimitive('123'); // true\n * isPrimitive(false); // true\n * isPrimitive(true); // true\n * isPrimitive(Symbol('a')); // true\n * isPrimitive(123n); // true\n * isPrimitive({}); // false\n * isPrimitive(new Date()); // false\n * isPrimitive(new Map()); // false\n * isPrimitive(new Set()); // false\n * isPrimitive([1, 2, 3]); // false\n */\nexport function isPrimitive(value: unknown): value is null | undefined | string | number | boolean | symbol | bigint {\n  return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n","/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *     Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n *\n * @example\n * const arr = new Uint8Array([1, 2, 3]);\n * isTypedArray(arr); // true\n *\n * const regularArray = [1, 2, 3];\n * isTypedArray(regularArray); // false\n *\n * const buffer = new ArrayBuffer(16);\n * isTypedArray(buffer); // false\n */\nexport function isTypedArray(\n  x: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n","import { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Creates a shallow clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A shallow clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n */\nexport function clone<T>(obj: T): T {\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n\n  if (\n    Array.isArray(obj) ||\n    isTypedArray(obj) ||\n    obj instanceof ArrayBuffer ||\n    (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)\n  ) {\n    return obj.slice(0) as T;\n  }\n\n  const prototype = Object.getPrototypeOf(obj);\n  const Constructor = prototype.constructor;\n\n  if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n    return new Constructor(obj);\n  }\n\n  if (obj instanceof RegExp) {\n    const newRegExp = new Constructor(obj);\n    newRegExp.lastIndex = obj.lastIndex;\n\n    return newRegExp;\n  }\n\n  if (obj instanceof DataView) {\n    return new Constructor(obj.buffer.slice(0));\n  }\n\n  if (obj instanceof Error) {\n    const newError = new Constructor(obj.message);\n\n    newError.stack = obj.stack;\n    newError.name = obj.name;\n    newError.cause = obj.cause;\n\n    return newError;\n  }\n\n  if (typeof File !== 'undefined' && obj instanceof File) {\n    const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n    return newFile;\n  }\n\n  if (typeof obj === 'object') {\n    const newObject = Object.create(prototype);\n    return Object.assign(newObject, obj);\n  }\n\n  return obj;\n}\n","export function getSymbols(object: any) {\n  return Object.getOwnPropertySymbols(object).filter(symbol =>\n    Object.prototype.propertyIsEnumerable.call(object, symbol)\n  );\n}\n","/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {T} value The value to query.\n * @returns {string} Returns the `Object.prototype.toString.call` result.\n */\nexport function getTag<T>(value: T) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n  return Object.prototype.toString.call(value);\n}\n","export const regexpTag = '[object RegExp]';\nexport const stringTag = '[object String]';\nexport const numberTag = '[object Number]';\nexport const booleanTag = '[object Boolean]';\nexport const argumentsTag = '[object Arguments]';\nexport const symbolTag = '[object Symbol]';\nexport const dateTag = '[object Date]';\nexport const mapTag = '[object Map]';\nexport const setTag = '[object Set]';\nexport const arrayTag = '[object Array]';\nexport const functionTag = '[object Function]';\nexport const arrayBufferTag = '[object ArrayBuffer]';\nexport const objectTag = '[object Object]';\nexport const errorTag = '[object Error]';\nexport const dataViewTag = '[object DataView]';\nexport const uint8ArrayTag = '[object Uint8Array]';\nexport const uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nexport const uint16ArrayTag = '[object Uint16Array]';\nexport const uint32ArrayTag = '[object Uint32Array]';\nexport const bigUint64ArrayTag = '[object BigUint64Array]';\nexport const int8ArrayTag = '[object Int8Array]';\nexport const int16ArrayTag = '[object Int16Array]';\nexport const int32ArrayTag = '[object Int32Array]';\nexport const bigInt64ArrayTag = '[object BigInt64Array]';\nexport const float32ArrayTag = '[object Float32Array]';\nexport const float64ArrayTag = '[object Float64Array]';\n","import { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { isPrimitive } from '../predicate/isPrimitive.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\n/**\n * Deeply clones the given object.\n *\n * You can customize the deep cloning process using the `cloneValue` function.\n * The function takes the current value `value`, the property name `key`, and the entire object `obj` as arguments.\n * If the function returns a value, that value is used;\n * if it returns `undefined`, the default cloning method is used.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @param {Function} [cloneValue] - A function to customize the cloning process.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive value\n * const num = 29;\n * const clonedNum = cloneDeepWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num); // true\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an array with a customizer\n * const arr = [1, 2, 3];\n * const clonedArr = cloneDeepWith(arr, (value) => {\n *   return value + 1; // Increment each value\n * });\n * console.log(clonedArr); // [2, 3, 4]\n * console.log(clonedArr === arr); // false\n */\nexport function cloneDeepWith<T>(\n  obj: T,\n  cloneValue: (value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any\n): T {\n  return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\n\nexport function cloneDeepWithImpl<T>(\n  valueToClone: any,\n  keyToClone: PropertyKey | undefined,\n  objectToClone: T,\n  stack = new Map<any, any>(),\n  cloneValue: ((value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any) | undefined = undefined\n): T {\n  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n\n  if (cloned != null) {\n    return cloned;\n  }\n\n  if (isPrimitive(valueToClone)) {\n    return valueToClone as T;\n  }\n\n  if (stack.has(valueToClone)) {\n    return stack.get(valueToClone) as T;\n  }\n\n  if (Array.isArray(valueToClone)) {\n    const result: any = new Array(valueToClone.length);\n    stack.set(valueToClone, result);\n\n    for (let i = 0; i < valueToClone.length; i++) {\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    }\n\n    // For RegExpArrays\n    if (Object.hasOwn(valueToClone, 'index')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.index = valueToClone.index;\n    }\n    if (Object.hasOwn(valueToClone, 'input')) {\n      // eslint-disable-next-line\n      // @ts-ignore\n      result.input = valueToClone.input;\n    }\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Date) {\n    return new Date(valueToClone.getTime()) as T;\n  }\n\n  if (valueToClone instanceof RegExp) {\n    const result = new RegExp(valueToClone.source, valueToClone.flags);\n\n    result.lastIndex = valueToClone.lastIndex;\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Map) {\n    const result = new Map();\n    stack.set(valueToClone, result);\n\n    for (const [key, value] of valueToClone) {\n      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n    }\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Set) {\n    const result = new Set();\n    stack.set(valueToClone, result);\n\n    for (const value of valueToClone) {\n      result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n    }\n\n    return result as T;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return valueToClone.subarray() as T;\n  }\n\n  if (isTypedArray(valueToClone)) {\n    const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n    stack.set(valueToClone, result);\n\n    for (let i = 0; i < valueToClone.length; i++) {\n      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n    }\n\n    return result as T;\n  }\n\n  if (\n    valueToClone instanceof ArrayBuffer ||\n    (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)\n  ) {\n    return valueToClone.slice(0) as T;\n  }\n\n  if (valueToClone instanceof DataView) {\n    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  // For legacy NodeJS support\n  if (typeof File !== 'undefined' && valueToClone instanceof File) {\n    const result = new File([valueToClone], valueToClone.name, {\n      type: valueToClone.type,\n    });\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Blob) {\n    const result = new Blob([valueToClone], { type: valueToClone.type });\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (valueToClone instanceof Error) {\n    const result = new (valueToClone.constructor as { new (): Error })();\n    stack.set(valueToClone, result);\n\n    result.message = valueToClone.message;\n    result.name = valueToClone.name;\n    result.stack = valueToClone.stack;\n    result.cause = valueToClone.cause;\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n    const result = Object.create(Object.getPrototypeOf(valueToClone));\n\n    stack.set(valueToClone, result);\n\n    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n\n    return result as T;\n  }\n\n  return valueToClone;\n}\n\nexport function copyProperties<T>(\n  target: any,\n  source: any,\n  objectToClone: T = target,\n  stack?: Map<any, any> | undefined,\n  cloneValue?: ((value: any, key: PropertyKey | undefined, obj: T, stack: Map<any, any>) => any) | undefined\n): void {\n  const keys = [...Object.keys(source), ...getSymbols(source)];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const descriptor = Object.getOwnPropertyDescriptor(target, key);\n\n    if (descriptor == null || descriptor.writable) {\n      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n    }\n  }\n}\n\nfunction isCloneableObject(object: object) {\n  switch (getTag(object)) {\n    case argumentsTag:\n    case arrayTag:\n    case arrayBufferTag:\n    case dataViewTag:\n    case booleanTag:\n    case dateTag:\n    case float32ArrayTag:\n    case float64ArrayTag:\n    case int8ArrayTag:\n    case int16ArrayTag:\n    case int32ArrayTag:\n    case mapTag:\n    case numberTag:\n    case objectTag:\n    case regexpTag:\n    case setTag:\n    case stringTag:\n    case symbolTag:\n    case uint8ArrayTag:\n    case uint8ClampedArrayTag:\n    case uint16ArrayTag:\n    case uint32ArrayTag: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n","import { cloneDeepWithImpl } from './cloneDeepWith.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepWithImpl(obj, undefined, obj, new Map(), undefined);\n}\n","/**\n * Finds the key of the first element in the object that satisfies the provided testing function.\n *\n * @param {T} obj - The object to search.\n * @param {(value: T[keyof T], key: keyof T, obj: T) => boolean} predicate - The function to execute on each value in the object. It takes three arguments:\n *   - value: The current value being processed in the object.\n *   - key: The key of the current value being processed in the object.\n *   - obj: The object that findKey was called upon.\n * @returns {keyof T | undefined} The key of the first element in the object that passes the test, or undefined if no element passes.\n *\n * @example\n * const users = {\n *   'barney':  { 'age': 36, 'active': true },\n *   'fred':    { 'age': 40, 'active': false },\n *   'pebbles': { 'age': 1,  'active': true }\n * };\n * findKey(users, function(o) { return o.age < 40; }); => 'barney'\n */\nexport function findKey<T extends Record<any, any>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T, obj: T) => boolean\n): keyof T | undefined {\n  const keys = Object.keys(obj) as Array<keyof T>;\n\n  return keys.find(key => predicate(obj[key], key, obj));\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * @param {object} value - The value to check.\n * @returns {value is Record<PropertyKey, any>} - True if the value is a plain object, otherwise false.\n *\n * @example\n * ```typescript\n * //  True\n *\n * isPlainObject({ });                       // \n * isPlainObject({ key: 'value' });          // \n * isPlainObject({ key: new Date() });       // \n * isPlainObject(new Object());              // \n * isPlainObject(Object.create(null));       // \n * isPlainObject({ nested: { key: true} });  // \n * isPlainObject(new Proxy({}, {}));         // \n * isPlainObject({ [Symbol('tag')]: 'A' });  // \n *\n * //  (cross-realms, node context, workers, ...)\n * const runInNewContext = await import('node:vm').then(\n *     (mod) => mod.runInNewContext\n * );\n * isPlainObject(runInNewContext('({})'));   // \n *\n * //  False\n *\n * class Test { };\n * isPlainObject(new Test())           // \n * isPlainObject(10);                  // \n * isPlainObject(null);                // \n * isPlainObject('hello');             // \n * isPlainObject([]);                  // \n * isPlainObject(new Date());          // \n * isPlainObject(new Uint8Array([1])); // \n * isPlainObject(Buffer.from('ABC'));  // \n * isPlainObject(Promise.resolve({})); // \n * isPlainObject(Object.create({}));   // \n * isPlainObject(new (class Cls {}));  // \n * isPlainObject(globalThis);          // ,\n * ```\n */\nexport function isPlainObject(value: unknown): value is Record<PropertyKey, any> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value) as typeof Object.prototype | null;\n\n  const hasObjectPrototype =\n    proto === null ||\n    proto === Object.prototype ||\n    // Required to support node:vm.runInNewContext({})\n    Object.getPrototypeOf(proto) === null;\n\n  if (!hasObjectPrototype) {\n    return false;\n  }\n\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\n\ninterface FlattenObjectOptions {\n  /**\n   * The delimiter to use between nested keys.\n   * @default '.'\n   */\n  delimiter?: string;\n}\n\n/**\n * Flattens a nested object into a single level object with delimiter-separated keys.\n *\n * @param {object} object - The object to flatten.\n * @param {string} [options.delimiter='.'] - The delimiter to use between nested keys.\n * @returns {Record<string, any>} - The flattened object.\n *\n * @example\n * const nestedObject = {\n *   a: {\n *     b: {\n *       c: 1\n *     }\n *   },\n *   d: [2, 3]\n * };\n *\n * const flattened = flattenObject(nestedObject);\n * console.log(flattened);\n * // Output:\n * // {\n * //   'a.b.c': 1,\n * //   'd.0': 2,\n * //   'd.1': 3\n * // }\n */\nexport function flattenObject(object: object, { delimiter = '.' }: FlattenObjectOptions = {}): Record<string, any> {\n  return flattenObjectImpl(object, '', delimiter);\n}\n\nfunction flattenObjectImpl(object: object, prefix = '', delimiter = '.'): Record<string, any> {\n  const result: Record<string, any> = {};\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (object as any)[key];\n\n    const prefixedKey = prefix ? `${prefix}${delimiter}${key}` : key;\n\n    if (isPlainObject(value) && Object.keys(value).length > 0) {\n      Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));\n      continue;\n    }\n\n    result[prefixedKey] = value;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with the same values as the given object, but with keys generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the new keys generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => K} getNewKey - The function invoked per own enumerable property.\n * @returns {Record<K, T[keyof T]>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapKeys(obj, (value, key) => key + value);\n * console.log(result); // { a1: 1, b2: 2 }\n */\nexport function mapKeys<T extends Record<PropertyKey, any>, K extends PropertyKey>(\n  object: T,\n  getNewKey: (value: T[keyof T], key: keyof T, object: T) => K\n): Record<K, T[keyof T]> {\n  const result = {} as Record<K, T[keyof T]>;\n  const keys = Object.keys(object) as Array<keyof T>;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = object[key];\n\n    result[getNewKey(value, key, object)] = value as any;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with the same keys as the given object, but with values generated\n * by running each own enumerable property of the object through the iteratee function.\n *\n * @template T - The type of the object.\n * @template K - The type of the keys in the object.\n * @template V - The type of the new values generated by the iteratee function.\n *\n * @param {T} object - The object to iterate over.\n * @param {(value: T[K], key: K, object: T) => V} getNewValue - The function invoked per own enumerable property.\n * @returns {Record<K, V>} - Returns the new mapped object.\n *\n * @example\n * // Example usage:\n * const obj = { a: 1, b: 2 };\n * const result = mapValues(obj, (value) => value * 2);\n * console.log(result); // { a: 2, b: 4 }\n */\nexport function mapValues<T extends object, K extends keyof T, V>(\n  object: T,\n  getNewValue: (value: T[K], key: K, object: T) => V\n): Record<K, V> {\n  const result = {} as Record<K, V>;\n  const keys = Object.keys(object);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as K;\n    const value = object[key];\n\n    result[key] = getNewValue(value, key, object);\n  }\n\n  return result;\n}\n","import { isPlainObject } from '../predicate/isPlainObject.ts';\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\n *\n * Note that this function mutates the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The source object whose properties will be merged into the target object.\n * @returns {T & S} The updated target object with properties from the source object merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<T extends Record<PropertyKey, any>, S extends Record<PropertyKey, any>>(\n  target: T,\n  source: S\n): T & S {\n  const sourceKeys = Object.keys(source) as Array<keyof S>;\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    const sourceValue = source[key];\n    const targetValue = target[key];\n\n    if (Array.isArray(sourceValue)) {\n      if (Array.isArray(targetValue)) {\n        target[key] = merge(targetValue, sourceValue);\n      } else {\n        target[key] = merge([], sourceValue);\n      }\n    } else if (isPlainObject(sourceValue)) {\n      if (isPlainObject(targetValue)) {\n        target[key] = merge(targetValue, sourceValue);\n      } else {\n        target[key] = merge({}, sourceValue);\n      }\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","/**\n * Checks if the given value is object-like.\n *\n * A value is object-like if its type is object and it is not null.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object-like value.\n *\n * @template T - The type of value.\n * @param {T} value - The value to test if it is an object-like.\n * @returns {value is object} `true` if the value is an object-like, `false` otherwise.\n *\n * @example\n * const value1 = { a: 1 };\n * const value2 = [1, 2, 3];\n * const value3 = 'abc';\n * const value4 = () => {};\n * const value5 = null;\n *\n * console.log(isObjectLike(value1)); // true\n * console.log(isObjectLike(value2)); // true\n * console.log(isObjectLike(value3)); // false\n * console.log(isObjectLike(value4)); // false\n * console.log(isObjectLike(value5)); // false\n */\n\nexport function isObjectLike(value?: unknown): value is object {\n  return typeof value === 'object' && value !== null;\n}\n","/**\n * Checks if the given value is a Blob.\n *\n * This function tests whether the provided value is an instance of `Blob`.\n * It returns `true` if the value is an instance of `Blob`, and `false` otherwise.\n *\n * @param {unknown} x - The value to test if it is a Blob.\n * @returns {x is Blob} True if the value is a Blob, false otherwise.\n *\n * @example\n * const value1 = new Blob();\n * const value2 = {};\n *\n * console.log(isBlob(value1)); // true\n * console.log(isBlob(value2)); // false\n */\nexport function isBlob(x: unknown): x is Blob {\n  // Return false if Blob is not supported in the environment\n  if (typeof Blob === 'undefined') {\n    return false;\n  }\n\n  return x instanceof Blob;\n}\n","declare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Checks if the given value is a Buffer instance.\n *\n * This function tests whether the provided value is an instance of Buffer.\n * It returns `true` if the value is a Buffer, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Buffer`.\n *\n * @param {unknown} x - The value to check if it is a Buffer.\n * @returns {boolean} Returns `true` if `x` is a Buffer, else `false`.\n *\n * @example\n * const buffer = Buffer.from(\"test\");\n * console.log(isBuffer(buffer)); // true\n *\n * const notBuffer = \"not a buffer\";\n * console.log(isBuffer(notBuffer)); // false\n */\nexport function isBuffer(x: unknown): boolean {\n  // eslint-disable-next-line\n  // @ts-ignore\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(x);\n}\n","/**\n * Performs a `SameValueZero` comparison between two values to determine if they are equivalent.\n *\n * @param {unknown} value - The value to compare.\n * @param {unknown} other - The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n *\n * @example\n * eq(1, 1); // true\n * eq(0, -0); // true\n * eq(NaN, NaN); // true\n * eq('a', Object('a')); // false\n */\nexport function eq(value?: unknown, other?: unknown): boolean {\n  return value === other || (Number.isNaN(value) && Number.isNaN(other));\n}\n","import { isPlainObject } from './isPlainObject.ts';\nimport { getSymbols } from '../compat/_internal/getSymbols.ts';\nimport { getTag } from '../compat/_internal/getTag.ts';\nimport {\n  argumentsTag,\n  arrayBufferTag,\n  arrayTag,\n  bigInt64ArrayTag,\n  bigUint64ArrayTag,\n  booleanTag,\n  dataViewTag,\n  dateTag,\n  errorTag,\n  float32ArrayTag,\n  float64ArrayTag,\n  functionTag,\n  int8ArrayTag,\n  int16ArrayTag,\n  int32ArrayTag,\n  mapTag,\n  numberTag,\n  objectTag,\n  regexpTag,\n  setTag,\n  stringTag,\n  symbolTag,\n  uint8ArrayTag,\n  uint8ClampedArrayTag,\n  uint16ArrayTag,\n  uint32ArrayTag,\n} from '../compat/_internal/tags.ts';\nimport { eq } from '../compat/util/eq.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Compares two values for equality using a custom comparison function.\n *\n * The custom function allows for fine-tuned control over the comparison process. If it returns a boolean, that result determines the equality. If it returns undefined, the function falls back to the default equality comparison.\n *\n * This function also uses the custom equality function to compare values inside objects,\n * arrays, maps, sets, and other complex structures, ensuring a deep comparison.\n *\n * This approach provides flexibility in handling complex comparisons while maintaining efficient default behavior for simpler cases.\n *\n * The custom comparison function can take up to six parameters:\n * - `x`: The value from the first object `a`.\n * - `y`: The value from the second object `b`.\n * - `property`: The property key used to get `x` and `y`.\n * - `xParent`: The parent of the first value `x`.\n * - `yParent`: The parent of the second value `y`.\n * - `stack`: An internal stack (Map) to handle circular references.\n *\n * @param {unknown} a - The first value to compare.\n * @param {unknown} b - The second value to compare.\n * @param {(x: any, y: any, property?: PropertyKey, xParent?: any, yParent?: any, stack?: Map<any, any>) => boolean | void} areValuesEqual - A function to customize the comparison.\n *   If it returns a boolean, that result will be used. If it returns undefined,\n *   the default equality comparison will be used.\n * @returns {boolean} `true` if the values are equal according to the customizer, otherwise `false`.\n *\n * @example\n * const customizer = (a, b) => {\n *   if (typeof a === 'string' && typeof b === 'string') {\n *     return a.toLowerCase() === b.toLowerCase();\n *   }\n * };\n * isEqualWith('Hello', 'hello', customizer); // true\n * isEqualWith({ a: 'Hello' }, { a: 'hello' }, customizer); // true\n * isEqualWith([1, 2, 3], [1, 2, 3], customizer); // true\n */\nexport function isEqualWith(\n  a: any,\n  b: any,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n): boolean {\n  return isEqualWithImpl(a, b, undefined, undefined, undefined, undefined, areValuesEqual);\n}\n\nfunction isEqualWithImpl(\n  a: any,\n  b: any,\n  property: PropertyKey | undefined,\n  aParent: any,\n  bParent: any,\n  stack: Map<any, any> | undefined,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n): boolean {\n  const result = areValuesEqual(a, b, property, aParent, bParent, stack);\n\n  if (result !== undefined) {\n    return result;\n  }\n\n  if (typeof a === typeof b) {\n    switch (typeof a) {\n      case 'bigint':\n      case 'string':\n      case 'boolean':\n      case 'symbol':\n      case 'undefined': {\n        return a === b;\n      }\n      case 'number': {\n        return a === b || Object.is(a, b);\n      }\n      case 'function': {\n        return a === b;\n      }\n      case 'object': {\n        return areObjectsEqual(a, b, stack, areValuesEqual);\n      }\n    }\n  }\n\n  return areObjectsEqual(a, b, stack, areValuesEqual);\n}\n\nfunction areObjectsEqual(\n  a: any,\n  b: any,\n  stack: Map<any, any> | undefined,\n  areValuesEqual: (\n    x: any,\n    y: any,\n    property?: PropertyKey,\n    xParent?: any,\n    yParent?: any,\n    stack?: Map<any, any>\n  ) => boolean | void\n) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  let aTag = getTag(a);\n  let bTag = getTag(b);\n\n  if (aTag === argumentsTag) {\n    aTag = objectTag;\n  }\n\n  if (bTag === argumentsTag) {\n    bTag = objectTag;\n  }\n\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case stringTag:\n      return a.toString() === b.toString();\n\n    case numberTag: {\n      const x = a.valueOf();\n      const y = b.valueOf();\n\n      return eq(x, y);\n    }\n\n    case booleanTag:\n    case dateTag:\n    case symbolTag:\n      return Object.is(a.valueOf(), b.valueOf());\n\n    case regexpTag: {\n      return a.source === b.source && a.flags === b.flags;\n    }\n\n    case functionTag: {\n      return a === b;\n    }\n  }\n\n  stack = stack ?? new Map();\n\n  const aStack = stack.get(a);\n  const bStack = stack.get(b);\n\n  if (aStack != null && bStack != null) {\n    return aStack === b;\n  }\n\n  stack.set(a, b);\n  stack.set(b, a);\n\n  try {\n    switch (aTag) {\n      case mapTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        for (const [key, value] of a.entries()) {\n          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case setTag: {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        const aValues = Array.from(a.values());\n        const bValues = Array.from(b.values());\n\n        for (let i = 0; i < aValues.length; i++) {\n          const aValue = aValues[i];\n          const index = bValues.findIndex(bValue => {\n            return isEqualWithImpl(aValue, bValue, undefined, a, b, stack, areValuesEqual);\n          });\n\n          if (index === -1) {\n            return false;\n          }\n\n          bValues.splice(index, 1);\n        }\n\n        return true;\n      }\n\n      case arrayTag:\n      case uint8ArrayTag:\n      case uint8ClampedArrayTag:\n      case uint16ArrayTag:\n      case uint32ArrayTag:\n      case bigUint64ArrayTag:\n      case int8ArrayTag:\n      case int16ArrayTag:\n      case int32ArrayTag:\n      case bigInt64ArrayTag:\n      case float32ArrayTag:\n      case float64ArrayTag: {\n        // Buffers are also treated as [object Uint8Array]s.\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\n          return false;\n        }\n\n        if (a.length !== b.length) {\n          return false;\n        }\n\n        for (let i = 0; i < a.length; i++) {\n          if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      case arrayBufferTag: {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n      }\n\n      case dataViewTag: {\n        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\n          return false;\n        }\n\n        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n      }\n\n      case errorTag: {\n        return a.name === b.name && a.message === b.message;\n      }\n\n      case objectTag: {\n        const areEqualInstances =\n          areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) ||\n          (isPlainObject(a) && isPlainObject(b));\n\n        if (!areEqualInstances) {\n          return false;\n        }\n\n        const aKeys = [...Object.keys(a), ...getSymbols(a)];\n        const bKeys = [...Object.keys(b), ...getSymbols(b)];\n\n        if (aKeys.length !== bKeys.length) {\n          return false;\n        }\n\n        for (let i = 0; i < aKeys.length; i++) {\n          const propKey = aKeys[i];\n          const aProp = (a as any)[propKey];\n\n          if (!Object.hasOwn(b, propKey)) {\n            return false;\n          }\n\n          const bProp = (b as any)[propKey];\n\n          if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      default: {\n        return false;\n      }\n    }\n  } finally {\n    stack.delete(a);\n    stack.delete(b);\n  }\n}\n","/**\n * The functions isJSONValue, isJSONArray, and isJSONObject are grouped in this file\n * to prevent any circular dependency issues.\n */\nimport { isPlainObject } from './isPlainObject.ts';\n\n/**\n * Checks if a given value is a valid JSON value.\n *\n * A valid JSON value can be:\n * - null\n * - a JSON object (an object with string keys and valid JSON values)\n * - a JSON array (an array of valid JSON values)\n * - a string\n * - a number\n * - a boolean\n *\n * @param {unknown} value - The value to check.\n * @returns {boolean} - True if the value is a valid JSON value, otherwise false.\n *\n * @example\n * console.log(isJSONValue(null)); // true\n * console.log(isJSONValue({ key: \"value\" })); // true\n * console.log(isJSONValue([1, 2, 3])); // true\n * console.log(isJSONValue(\"Hello\")); // true\n * console.log(isJSONValue(42)); // true\n * console.log(isJSONValue(true)); // true\n * console.log(isJSONValue(undefined)); // false\n * console.log(isJSONValue(() => {})); // false\n */\nexport function isJSONValue(value: unknown): value is Record<string, any> | any[] | string | number | boolean | null {\n  switch (typeof value) {\n    case 'object': {\n      return value === null || isJSONArray(value) || isJSONObject(value);\n    }\n    case 'string':\n    case 'number':\n    case 'boolean': {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/**\n * Checks if a given value is a valid JSON array.\n *\n * A valid JSON array is defined as an array where all items are valid JSON values.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is any[]} - True if the value is a valid JSON array, otherwise false.\n *\n * @example\n * console.log(isJSONArray([1, 2, 3])); // true\n * console.log(isJSONArray([\"string\", null, true])); // true\n * console.log(isJSONArray([1, 2, () => {}])); // false\n * console.log(isJSONArray(\"not an array\")); // false\n */\nexport function isJSONArray(value: unknown): value is any[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  return value.every(item => isJSONValue(item));\n}\n\n/**\n * Checks if a value is a JSON object.\n *\n * A valid JSON object is defined as an object with string keys and valid JSON values.\n *\n * @param {unknown} obj The value to check.\n * @returns {obj is Record<string, any>} True if `obj` is a JSON object, false otherwise.\n *\n * @example\n * isJSONObject({ nested: { boolean: true, array: [1, 2, 3], string: 'test', null: null } }); // true\n * isJSONObject({ regexp: /test/ }); // false\n * isJSONObject(123); // false\n */\nexport function isJSONObject(obj: unknown): obj is Record<string, any> {\n  if (!isPlainObject(obj)) {\n    return false;\n  }\n\n  const keys = Reflect.ownKeys(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = obj[key];\n\n    if (typeof key !== 'string') {\n      return false;\n    }\n\n    if (!isJSONValue(value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Checks if a given value is a valid length.\n *\n * A valid length is of type `number`, is a non-negative integer, and is less than or equal to\n * JavaScript's maximum safe integer (`Number.MAX_SAFE_INTEGER`).\n * It returns `true` if the value is a valid length, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the\n * argument to a valid length (`number`).\n *\n * @param {unknown} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n *\n * @example\n * isLength(0); // true\n * isLength(42); // true\n * isLength(-1); // false\n * isLength(1.5); // false\n * isLength(Number.MAX_SAFE_INTEGER); // true\n * isLength(Number.MAX_SAFE_INTEGER + 1); // false\n */\nexport function isLength(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x: unknown): x is null | undefined {\n  return x == null;\n}\n","/**\n * Checks if the given value is null.\n *\n * This function tests whether the provided value is strictly equal to `null`.\n * It returns `true` if the value is `null`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\n *\n * @param {unknown} x - The value to test if it is null.\n * @returns {x is null} True if the value is null, false otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n *\n * console.log(isNull(value1)); // true\n * console.log(isNull(value2)); // false\n * console.log(isNull(value3)); // false\n */\nexport function isNull(x: unknown): x is null {\n  return x === null;\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n *\n * @example\n * import { isSymbol } from 'es-toolkit/predicate';\n *\n * isSymbol(Symbol('a')); // true\n * isSymbol(Symbol.for('a')); // true\n * isSymbol(Symbol.iterator); // true\n *\n * isSymbol(null); // false\n * isSymbol(undefined); // false\n * isSymbol('123'); // false\n * isSymbol(false); // false\n * isSymbol(123n); // false\n * isSymbol({}); // false\n * isSymbol([1, 2, 3]); // false\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === 'symbol';\n}\n","/**\n * Checks if the given value is undefined.\n *\n * This function tests whether the provided value is strictly equal to `undefined`.\n * It returns `true` if the value is `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\n *\n * @param {unknown} x - The value to test if it is undefined.\n * @returns {x is undefined} true if the value is undefined, false otherwise.\n *\n * @example\n * const value1 = undefined;\n * const value2 = null;\n * const value3 = 42;\n *\n * console.log(isUndefined(value1)); // true\n * console.log(isUndefined(value2)); // false\n * console.log(isUndefined(value3)); // false\n */\nexport function isUndefined(x: unknown): x is undefined {\n  return x === undefined;\n}\n","/**\n * Converts the first character of string to upper case and the remaining to lower case.\n *\n * @template T - Literal type of the string.\n * @param {T} str - The string to be converted to uppercase.\n * @returns {Capitalize<T>} - The capitalized string.\n *\n * @example\n * const result = capitalize('fred') // returns 'Fred'\n * const result2 = capitalize('FRED') // returns 'Fred'\n */\n\nexport function capitalize<T extends string>(str: T): Capitalize<T> {\n  return (str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()) as Capitalize<T>;\n}\n\ntype Capitalize<T extends string> = T extends `${infer F}${infer R}` ? `${Uppercase<F>}${Lowercase<R>}` : T;\n","/**\n * Regular expression pattern to split strings into words for various case conversions\n *\n * This pattern matches sequences of characters in a string, considering the following cases:\n * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)\n * - Sequences of one uppercase letter optionally followed by lowercase letters and digits\n * - Single uppercase letters\n * - Sequences of digits\n * - Emojis and other Unicode characters\n *\n * The resulting match can be used to convert camelCase, snake_case, kebab-case, and other mixed formats into\n * a consistent format like snake case. It also supports emojis and other Unicode characters.\n *\n * @example\n * const matches = 'camelCaseHTTPRequest'.match(CASE_SPLIT_PATTERN);\n * // matches: ['camel', 'Case', 'HTTP', 'Request', '']\n */\nexport const CASE_SPLIT_PATTERN =\n  /\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+/gu;\n\n/**\n * Splits `string` into an array of its words, treating spaces and punctuation marks as separators.\n *\n * @param {string} str The string to inspect.\n * @param {RegExp | string} [pattern] The pattern to match words.\n * @returns {string[]} Returns the words of `string`.\n *\n * @example\n * words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * words('camelCaseHTTPRequest');\n * // => ['camel', 'Case', 'HTTP', 'Request', '']\n *\n * words('Luned 18 Set')\n * // => ['Luned', '18', 'Set']\n */\nexport function words(str: string): string[] {\n  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);\n}\n","const deburrMap = new Map<string, string>(\n  // eslint-disable-next-line no-restricted-syntax\n  Object.entries({\n    : 'Ae',\n    : 'D',\n    : 'O',\n    : 'Th',\n    : 'ss',\n    : 'ae',\n    : 'd',\n    : 'o',\n    : 'th',\n    : 'D',\n    : 'd',\n    : 'H',\n    : 'h',\n    : 'i',\n    : 'IJ',\n    : 'ij',\n    : 'k',\n    : 'L',\n    : 'l',\n    : 'L',\n    : 'l',\n    : \"'n\",\n    : 'N',\n    : 'n',\n    : 'Oe',\n    : 'oe',\n    : 'T',\n    : 't',\n    : 's',\n  })\n);\n\n/**\n * Converts a string by replacing special characters and diacritical marks with their ASCII equivalents.\n * For example, \"Crme brle\" becomes \"Creme brulee\".\n *\n * @param {string} str - The input string to be deburred.\n * @returns {string} - The deburred string with special characters replaced by their ASCII equivalents.\n *\n * @example\n * // Basic usage:\n * deburr('thelred') // returns 'Aethelred'\n *\n * @example\n * // Handling diacritical marks:\n * deburr('Mnchen') // returns 'Munchen'\n *\n * @example\n * // Special characters:\n * deburr('Crme brle') // returns 'Creme brulee'\n */\nexport function deburr(str: string): string {\n  str = str.normalize('NFD');\n\n  let result = '';\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n\n    if ((char >= '\\u0300' && char <= '\\u036f') || (char >= '\\ufe20' && char <= '\\ufe23')) {\n      continue;\n    }\n\n    result += deburrMap.get(char) ?? char;\n  }\n\n  return result;\n}\n","const htmlEscapes: Record<string, string> = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\n * For example, \"<\" becomes \"&lt;\".\n *\n * @param {string} str  The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * escape('This is a <div> element.'); // returns 'This is a &lt;div&gt; element.'\n * escape('This is a \"quote\"'); // returns 'This is a &quot;quote&quot;'\n * escape(\"This is a 'quote'\"); // returns 'This is a &#39;quote&#39;'\n * escape('This is a & symbol'); // returns 'This is a &amp; symbol'\n */\nexport function escape(str: string): string {\n  return str.replace(/[&<>\"']/g, match => htmlEscapes[match]);\n}\n","/**\n * Removes trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which trailing characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the end of the string.\n * @returns {string} - The resulting string after the specified trailing character has been removed.\n *\n * @example\n * const trimmedStr1 = trimEnd('hello---', '-') // returns 'hello'\n * const trimmedStr2 = trimEnd('123000', '0') // returns '123'\n * const trimmedStr3 = trimEnd('abcabcabc', 'c') // returns 'abcabcab'\n * const trimmedStr4 = trimEnd('trimmedxxx', 'x') // returns 'trimmed'\n */\nexport function trimEnd(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trimEnd();\n  }\n\n  let endIndex = str.length;\n\n  switch (typeof chars) {\n    case 'string': {\n      while (endIndex > 0 && str[endIndex - 1] === chars) {\n        endIndex--;\n      }\n      break;\n    }\n    case 'object': {\n      while (endIndex > 0 && chars.includes(str[endIndex - 1])) {\n        endIndex--;\n      }\n    }\n  }\n\n  return str.substring(0, endIndex);\n}\n","/**\n * Removes leading whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which leading characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the start of the string.\n * @returns {string} - The resulting string after the specified leading character has been removed.\n *\n * @example\n * const trimmedStr1 = trimStart('---hello', '-') // returns 'hello'\n * const trimmedStr2 = trimStart('000123', '0') // returns '123'\n * const trimmedStr3 = trimStart('abcabcabc', 'a') // returns 'bcabcabc'\n * const trimmedStr4 = trimStart('xxxtrimmed', 'x') // returns 'trimmed'\n */\nexport function trimStart(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trimStart();\n  }\n  let startIndex = 0;\n\n  switch (typeof chars) {\n    case 'string': {\n      while (startIndex < str.length && str[startIndex] === chars) {\n        startIndex++;\n      }\n      break;\n    }\n    case 'object': {\n      while (startIndex < str.length && chars.includes(str[startIndex])) {\n        startIndex++;\n      }\n    }\n  }\n\n  return str.substring(startIndex);\n}\n","import { trimEnd } from './trimEnd.ts';\nimport { trimStart } from './trimStart.ts';\n\n/**\n * Removes leading and trailing whitespace or specified characters from a string.\n *\n * @param {string} str - The string from which characters will be trimmed.\n * @param {string | string[]} chars - The character(s) to remove from the string. Can be a single character or an array of characters.\n * @returns {string} - The resulting string after the specified characters have been removed.\n *\n * @example\n * trim(\"  hello  \"); // \"hello\"\n * trim(\"--hello--\", \"-\"); // \"hello\"\n * trim(\"##hello##\", [\"#\", \"o\"]); // \"hell\"\n */\nexport function trim(str: string, chars?: string | string[]): string {\n  if (chars === undefined) {\n    return str.trim();\n  }\n\n  return trimStart(trimEnd(str, chars), chars);\n}\n","const htmlUnescapes: Record<string, string> = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&#39;': \"'\",\n};\n\n/**\n * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.\n * It is the inverse of `escape`.\n *\n * @param {string} str The string to unescape.\n * @returns {string} Returns the unescaped string.\n *\n * @example\n * unescape('This is a &lt;div&gt; element.'); // returns 'This is a <div> element.'\n * unescape('This is a &quot;quote&quot;'); // returns 'This is a \"quote\"'\n * unescape('This is a &#39;quote&#39;'); // returns 'This is a 'quote''\n * unescape('This is a &amp; symbol'); // returns 'This is a & symbol'\n */\nexport function unescape(str: string): string {\n  return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, match => htmlUnescapes[match] || \"'\");\n}\n","export function toArray<T>(value: ArrayLike<T>): T[] {\n  return Array.isArray(value) ? value : Array.from(value);\n}\n","import { isLength } from '../../predicate/isLength.ts';\n\n/**\n * Checks if `value` is array-like.\n *\n * @param {unknown} value The value to check.\n * @returns {value is ArrayLike<unknown>} Returns `true` if `value` is array-like, else `false`.\n *\n * @example\n * isArrayLike([1, 2, 3]); // true\n * isArrayLike('abc'); // true\n * isArrayLike({ 0: 'a', length: 1 }); // true\n * isArrayLike({}); // false\n * isArrayLike(null); // false\n * isArrayLike(undefined); // false\n */\nexport function isArrayLike(value?: unknown): value is ArrayLike<unknown> {\n  return value != null && typeof value !== 'function' && isLength((value as ArrayLike<unknown>).length);\n}\n","import { isArrayLike } from './isArrayLike.ts';\nimport { isObjectLike } from './isObjectLike.ts';\n\n/**\n * Checks if the given value is a non-primitive, array-like object.\n *\n * @param {unknown} value The value to check.\n * @returns {value is ArrayLike<unknown> & object} `true` if the value is a non-primitive, array-like object, `false` otherwise.\n *\n * @example\n * isArrayLikeObject([1, 2, 3]); // true\n * isArrayLikeObject({ 0: 'a', length: 1 }); // true\n * isArrayLikeObject('abc'); // false\n * isArrayLikeObject(()=>{}); // false\n */\nexport function isArrayLikeObject(value?: unknown): value is ArrayLike<unknown> & object {\n  return isObjectLike(value) && isArrayLike(value);\n}\n","import { last as lastToolkit } from '../../array/last.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns the last element of an array.\n *\n * This function takes an array and returns the last element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * Unlike some implementations, this function is optimized for performance\n * by directly accessing the last index of the array.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array from which to get the last element.\n * @returns {T | undefined} The last element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const lastElement = last(arr);\n * // lastElement will be 3\n *\n * const emptyArr: number[] = [];\n * const noElement = last(emptyArr);\n * // noElement will be undefined\n */\nexport function last<T>(array: ArrayLike<T> | null | undefined): T | undefined {\n  if (!isArrayLike(array)) {\n    return undefined;\n  }\n  return lastToolkit(toArray(array));\n}\n","import { isArrayLikeObject } from '../predicate/isArrayLikeObject.ts';\n\nexport function flattenArrayLike<T>(values: Array<ArrayLike<T> | unknown>): T[] {\n  const result: T[] = [];\n\n  for (let i = 0; i < values.length; i++) {\n    const arrayLike = values[i];\n\n    if (!isArrayLikeObject(arrayLike)) {\n      continue;\n    }\n\n    for (let j = 0; j < arrayLike.length; j++) {\n      result.push(arrayLike[j] as T);\n    }\n  }\n\n  return result;\n}\n","/**\n * Checks if a given key is a deep key.\n *\n * A deep key is a string that contains a dot (.) or square brackets with a property accessor.\n *\n * @param {PropertyKey} key - The key to check.\n * @returns {boolean} - Returns true if the key is a deep key, otherwise false.\n *\n * Examples:\n *\n * isDeepKey('a.b') // true\n * isDeepKey('a[b]') // true\n * isDeepKey('a') // false\n * isDeepKey(123) // false\n * isDeepKey('a.b.c') // true\n * isDeepKey('a[b][c]') // true\n */\nexport function isDeepKey(key: PropertyKey): boolean {\n  switch (typeof key) {\n    case 'number':\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return key.includes('.') || key.includes('[') || key.includes(']');\n    }\n  }\n}\n","/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nexport function toKey(value: number) {\n  if (Object.is(value, -0)) {\n    return '-0';\n  }\n  return value.toString();\n}\n","/**\n * Converts a deep key string into an array of path segments.\n *\n * This function takes a string representing a deep key (e.g., 'a.b.c' or 'a[b][c]') and breaks it down into an array of strings, each representing a segment of the path.\n *\n * @param {string} deepKey - The deep key string to convert.\n * @returns {string[]} An array of strings, each representing a segment of the path.\n *\n * Examples:\n *\n * toPath('a.b.c') // Returns ['a', 'b', 'c']\n * toPath('a[b][c]') // Returns ['a', 'b', 'c']\n * toPath('.a.b.c') // Returns ['', 'a', 'b', 'c']\n * toPath('a[\"b.c\"].d') // Returns ['a', 'b.c', 'd']\n * toPath('') // Returns []\n * toPath('.a[b].c.d[e][\"f.g\"].h') // Returns ['', 'a', 'b', 'c', 'd', 'e', 'f.g', 'h']\n */\nexport function toPath(deepKey: string): string[] {\n  const result: string[] = [];\n  const length = deepKey.length;\n\n  if (length === 0) {\n    return result;\n  }\n\n  let index = 0;\n  let key = '';\n  let quoteChar = '';\n  let bracket = false;\n\n  // Leading dot\n  if (deepKey.charCodeAt(0) === 46) {\n    result.push('');\n    index++;\n  }\n\n  while (index < length) {\n    const char = deepKey[index];\n\n    if (quoteChar) {\n      if (char === '\\\\' && index + 1 < length) {\n        // Escape character\n        index++;\n        key += deepKey[index];\n      } else if (char === quoteChar) {\n        // End of quote\n        quoteChar = '';\n      } else {\n        key += char;\n      }\n    } else if (bracket) {\n      if (char === '\"' || char === \"'\") {\n        // Start of quoted string inside brackets\n        quoteChar = char;\n      } else if (char === ']') {\n        // End of bracketed segment\n        bracket = false;\n        result.push(key);\n        key = '';\n      } else {\n        key += char;\n      }\n    } else {\n      if (char === '[') {\n        // Start of bracketed segment\n        bracket = true;\n        if (key) {\n          result.push(key);\n          key = '';\n        }\n      } else if (char === '.') {\n        if (key) {\n          result.push(key);\n          key = '';\n        }\n      } else {\n        key += char;\n      }\n    }\n\n    index++;\n  }\n\n  if (key) {\n    result.push(key);\n  }\n\n  return result;\n}\n","import type { Get } from './get.types.ts';\nimport { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n * @template D - The type of the default value.\n *\n * @param {T} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @returns {T[K]} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T>(object: T, path: K | readonly [K]): T[K];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @returns {T[K] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T>(\n  object: T | null | undefined,\n  path: K | readonly [K]\n): T[K] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K - The type of the key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {K | [K]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K extends keyof T, D>(\n  object: T | null | undefined,\n  path: K | readonly [K],\n  defaultValue: D\n): Exclude<T[K], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @returns {T[K1][K2]} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\n  object: T,\n  path: readonly [K1, K2]\n): T[K1][K2];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @returns {T[K1][K2] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1]>(\n  object: T | null | undefined,\n  path: readonly [K1, K2]\n): T[K1][K2] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], D>(\n  object: T | null | undefined,\n  path: readonly [K1, K2],\n  defaultValue: D\n): Exclude<T[K1][K2], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @returns {T[K1][K2][K3]} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  object: T,\n  path: readonly [K1, K2, K3]\n): T[K1][K2][K3];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @returns {T[K1][K2][K3] | undefined} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  object: T | null | undefined,\n  path: readonly [K1, K2, K3]\n): T[K1][K2][K3] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2][K3], undefined> | D} - Returns the resolved value.\n */\nexport function get<T extends object, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], D>(\n  object: T | null | undefined,\n  path: readonly [K1, K2, K3],\n  defaultValue: D\n): Exclude<T[K1][K2][K3], undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n *\n * @param {T} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @returns {T[K1][K2][K3][K4]} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n>(object: T, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4];\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @returns {T[K1][K2][K3][K4] | undefined} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n>(object: T | null | undefined, path: readonly [K1, K2, K3, K4]): T[K1][K2][K3][K4] | undefined;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template K1 - The type of the first key in the object.\n * @template K2 - The type of the second key in the object.\n * @template K3 - The type of the third key in the object.\n * @template K4 - The type of the fourth key in the object.\n * @template D - The type of the default value.\n *\n * @param {T | null | undefined} object - The object to query.\n * @param {[K1, K2, K3, K4]} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<T[K1][K2][K3][K4], undefined> | D} - Returns the resolved value.\n */\nexport function get<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  D,\n>(\n  object: T | null | undefined,\n  path: readonly [K1, K2, K3, K4],\n  defaultValue: D\n): Exclude<T[K1][K2][K3][K4], undefined> | D;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n *\n * @param {Record<number, T>} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T} - Returns the resolved value.\n */\nexport function get<T>(object: Record<number, T>, path: number): T;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n *\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @returns {T | undefined} - Returns the resolved value.\n */\nexport function get<T>(object: Record<number, T> | null | undefined, path: number): T | undefined;\n/**\n * Retrieves the value at a given path from an object with numeric keys. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the value.\n * @template D - The type of the default value.\n *\n * @param {Record<number, T> | null | undefined} object - The object to query.\n * @param {number} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {T | D} - Returns the resolved value.\n */\nexport function get<T, D>(object: Record<number, T> | null | undefined, path: number, defaultValue: D): T | D;\n/**\n * Retrieves the value at a given path from a null or undefined object, returning the default value.\n *\n * @template D - The type of the default value.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyKey} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {D} - Returns the default value.\n */\nexport function get<D>(object: null | undefined, path: PropertyKey, defaultValue: D): D;\n/**\n * Retrieves the value at a given path from a null or undefined object, returning undefined.\n *\n * @param {null | undefined} object - The object to query.\n * @param {PropertyKey} path - The path of the property to get.\n * @returns {undefined} - Returns undefined.\n */\nexport function get(object: null | undefined, path: PropertyKey): undefined;\n/**\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template P - The type of the path.\n *\n * @param {T} data - The object to query.\n * @param {P} path - The path of the property to get.\n * @returns {string extends P ? any : Get<T, P>} - Returns the resolved value.\n */\nexport function get<T, P extends string>(data: T, path: P): string extends P ? any : Get<T, P>;\n/**\n * Retrieves the value at a given path from a string-keyed object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @template T - The type of the object.\n * @template P - The type of the path.\n * @template D - The type of the default value.\n *\n * @param {T} data - The object to query.\n * @param {P} path - The path of the property to get.\n * @param {D} defaultValue - The value returned if the resolved value is undefined.\n * @returns {Exclude<Get<T, P>, null | undefined> | D} - Returns the resolved value.\n */\nexport function get<T, P extends string, D = Get<T, P>>(\n  data: T,\n  path: P,\n  defaultValue: D\n): Exclude<Get<T, P>, null | undefined> | D;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} - Returns the resolved value.\n */\nexport function get(object: unknown, path: PropertyKey | readonly PropertyKey[], defaultValue?: unknown): any;\n/**\n * Retrieves the value at a given path from an object. If the resolved value is undefined, the defaultValue is returned instead.\n *\n * @param {unknown} object - The object to query.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to get.\n * @param {unknown} [defaultValue] - The value returned if the resolved value is undefined.\n * @returns {any} - Returns the resolved value.\n */\nexport function get(object: any, path: PropertyKey | readonly PropertyKey[], defaultValue?: any): any {\n  if (object == null) {\n    return defaultValue;\n  }\n\n  switch (typeof path) {\n    case 'string': {\n      const result = object[path];\n\n      if (result === undefined) {\n        if (isDeepKey(path)) {\n          return get(object, toPath(path), defaultValue);\n        } else {\n          return defaultValue;\n        }\n      }\n\n      return result;\n    }\n    case 'number':\n    case 'symbol': {\n      if (typeof path === 'number') {\n        path = toKey(path);\n      }\n\n      const result = object[path];\n\n      if (result === undefined) {\n        return defaultValue;\n      }\n\n      return result;\n    }\n    default: {\n      if (Array.isArray(path)) {\n        return getWithPath(object, path, defaultValue);\n      }\n\n      if (Object.is(path?.valueOf(), -0)) {\n        path = '-0';\n      } else {\n        path = String(path);\n      }\n\n      const result = object[path];\n\n      if (result === undefined) {\n        return defaultValue;\n      }\n\n      return result;\n    }\n  }\n}\n\nfunction getWithPath(object: any, path: readonly PropertyKey[], defaultValue?: any): any {\n  if (path.length === 0) {\n    return defaultValue;\n  }\n\n  let current = object;\n\n  for (let index = 0; index < path.length; index++) {\n    if (current == null) {\n      return defaultValue;\n    }\n\n    current = current[path[index]];\n  }\n\n  if (current === undefined) {\n    return defaultValue;\n  }\n\n  return current;\n}\n","import { get } from './get.ts';\n\n/**\n * Creates a function that returns the value at a given path of an object.\n *\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to get.\n * @returns {(object: unknown) => any} - Returns a new function that takes an object and returns the value at the specified path.\n *\n * @example\n * const getObjectValue = property('a.b.c');\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n *\n * @example\n * const getObjectValue = property(['a', 'b', 'c']);\n * const result = getObjectValue({ a: { b: { c: 3 } } });\n * console.log(result); // => 3\n */\nexport function property(path: PropertyKey | readonly PropertyKey[]): (object: unknown) => any {\n  return function (object: unknown) {\n    return get(object, path);\n  };\n}\n","/**\n * Checks if the given value is an object. An object is a value that is\n * not a primitive type (string, number, boolean, symbol, null, or undefined).\n *\n * This function tests whether the provided value is an object or not.\n * It returns `true` if the value is an object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an object value.\n *\n * @param {unknown} value - The value to check if it is an object.\n * @returns {value is object} `true` if the value is an object, `false` otherwise.\n *\n * @example\n * const value1 = {};\n * const value2 = [1, 2, 3];\n * const value3 = () => {};\n * const value4 = null;\n *\n * console.log(isObject(value1)); // true\n * console.log(isObject(value2)); // true\n * console.log(isObject(value3)); // true\n * console.log(isObject(value4)); // false\n */\n\nexport function isObject(value?: unknown): value is object {\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n","import { isObject } from './isObject.ts';\nimport { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Checks if the target matches the source by comparing their structures and values.\n * This function supports deep comparison for objects, arrays, maps, and sets.\n *\n * @param {unknown} target - The target value to match against.\n * @param {unknown} source - The source value to match with.\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\n *\n * @example\n * // Matching arrays\n * isMatch([1, 2, 3], [1, 2, 3]); // true\n *\n * @example\n * // Matching maps\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\n * const sourceMap = new Map([['key1', 'value1']]);\n * isMatch(targetMap, sourceMap); // true\n *\n * @example\n * // Matching sets\n * const targetSet = new Set([1, 2, 3]);\n * const sourceSet = new Set([1, 2]);\n * isMatch(targetSet, sourceSet); // true\n */\nexport function isMatch(target: unknown, source: unknown): boolean;\n/**\n * Checks if the target matches the source by comparing their structures and values.\n * This function supports deep comparison for objects, arrays, maps, and sets.\n *\n * @param {unknown} target - The target value to match against.\n * @param {unknown} source - The source value to match with.\n * @returns {boolean} - Returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * isMatch({ a: 1, b: 2 }, { a: 1 }); // true\n *\n * @example\n * // Matching arrays\n * isMatch([1, 2, 3], [1, 2, 3]); // true\n *\n * @example\n * // Matching maps\n * const targetMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\n * const sourceMap = new Map([['key1', 'value1']]);\n * isMatch(targetMap, sourceMap); // true\n *\n * @example\n * // Matching sets\n * const targetSet = new Set([1, 2, 3]);\n * const sourceSet = new Set([1, 2]);\n * isMatch(targetSet, sourceSet); // true\n */\nexport function isMatch(target: any, source: any): boolean {\n  if (source === target) {\n    return true;\n  }\n\n  switch (typeof source) {\n    case 'object': {\n      if (source == null) {\n        return true;\n      }\n\n      const keys = Object.keys(source as any);\n\n      if (target == null) {\n        return keys.length === 0;\n      }\n\n      if (Array.isArray(source)) {\n        return isArrayMatch(target, source);\n      }\n\n      if (source instanceof Map) {\n        return isMapMatch(target, source);\n      }\n\n      if (source instanceof Set) {\n        return isSetMatch(target, source);\n      }\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (!isPrimitive(target) && !(key in target)) {\n          return false;\n        }\n\n        if (source[key] === undefined && target[key] !== undefined) {\n          return false;\n        }\n\n        if (source[key] === null && target[key] !== null) {\n          return false;\n        }\n\n        if (!isMatch(target[key], source[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    case 'function': {\n      if (Object.keys(source).length > 0) {\n        return isMatch(target, { ...source });\n      }\n\n      return false;\n    }\n    default: {\n      if (!isObject(target)) {\n        return eq(target, source);\n      }\n\n      return !source;\n    }\n  }\n}\n\nexport function isMapMatch(target: unknown, source: Map<any, any>) {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Map)) {\n    return false;\n  }\n\n  for (const [key, value] of source.entries()) {\n    if (!isMatch(target.get(key), value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isArrayMatch(target: unknown, source: readonly unknown[]) {\n  if (source.length === 0) {\n    return true;\n  }\n\n  if (!Array.isArray(target)) {\n    return false;\n  }\n\n  const countedIndex = new Set<number>();\n\n  for (let i = 0; i < source.length; i++) {\n    const sourceItem = source[i];\n    const index = target.findIndex((targetItem, index) => {\n      return isMatch(targetItem, sourceItem) && !countedIndex.has(index);\n    });\n\n    if (index === -1) {\n      return false;\n    }\n\n    countedIndex.add(index);\n  }\n\n  return true;\n}\n\nexport function isSetMatch(target: unknown, source: Set<any>) {\n  if (source.size === 0) {\n    return true;\n  }\n\n  if (!(target instanceof Set)) {\n    return false;\n  }\n\n  return isArrayMatch([...target], [...source]);\n}\n","import { isMatch } from './isMatch.ts';\nimport { cloneDeep } from '../../object/cloneDeep.ts';\n\n/**\n * Creates a function that performs a deep comparison between a given target and the source object.\n *\n * @param {unknown} source - The source object to create the matcher from.\n * @returns {(target: unknown) => boolean} - Returns a function that takes a target object and returns `true` if the target matches the source, otherwise `false`.\n *\n * @example\n * // Basic usage\n * const matcher = matches({ a: 1, b: 2 });\n * matcher({ a: 1, b: 2, c: 3 }); // true\n * matcher({ a: 1, c: 3 }); // false\n *\n * @example\n * // Matching arrays\n * const arrayMatcher = matches([1, 2, 3]);\n * arrayMatcher([1, 2, 3, 4]); // true\n * arrayMatcher([4, 5, 6]); // false\n *\n * @example\n * // Matching objects with nested structures\n * const nestedMatcher = matches({ a: { b: 2 } });\n * nestedMatcher({ a: { b: 2, c: 3 } }); // true\n * nestedMatcher({ a: { c: 3 } }); // false\n */\nexport function matches(source: unknown): (target: unknown) => boolean {\n  source = cloneDeep(source);\n\n  return (target?: unknown): boolean => {\n    return isMatch(target, source);\n  };\n}\n","import { cloneDeepWith as cloneDeepWithToolkit } from '../../object/cloneDeepWith.ts';\nimport { copyProperties } from '../../object/cloneDeepWith.ts';\nimport { argumentsTag, booleanTag, numberTag, stringTag } from '../_internal/tags.ts';\n\n/**\n * Creates a deep clone of the given object using a customizer function.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @param {Function} [cloneValue] - A function to customize the cloning process.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive value\n * const num = 29;\n * const clonedNum = cloneDeepWith(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num); // true\n *\n * @example\n * // Clone an object with a customizer\n * const obj = { a: 1, b: 2 };\n * const clonedObj = cloneDeepWith(obj, (value) => {\n *   if (typeof value === 'number') {\n *     return value * 2; // Double the number\n *   }\n * });\n * console.log(clonedObj); // { a: 2, b: 4 }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an array with a customizer\n * const arr = [1, 2, 3];\n * const clonedArr = cloneDeepWith(arr, (value) => {\n *   return value + 1; // Increment each value\n * });\n * console.log(clonedArr); // [2, 3, 4]\n * console.log(clonedArr === arr); // false\n */\nexport function cloneDeepWith<T>(\n  obj: T,\n  cloneValue?: (value: any, key: PropertyKey | undefined, object: T | undefined, stack: Map<any, any>) => any\n): T {\n  return cloneDeepWithToolkit(obj, (value, key, object, stack) => {\n    const cloned = cloneValue?.(value, key, object, stack);\n\n    if (cloned != null) {\n      return cloned;\n    }\n\n    if (typeof obj !== 'object') {\n      return undefined;\n    }\n\n    switch (Object.prototype.toString.call(obj)) {\n      case numberTag:\n      case stringTag:\n      case booleanTag: {\n        // eslint-disable-next-line\n        // @ts-ignore\n        const result = new obj.constructor(obj?.valueOf()) as T;\n        copyProperties(result, obj);\n        return result;\n      }\n\n      case argumentsTag: {\n        const result = {} as any;\n\n        copyProperties(result, obj);\n\n        // eslint-disable-next-line\n        // @ts-ignore\n        result.length = obj.length;\n        // eslint-disable-next-line\n        // @ts-ignore\n        result[Symbol.iterator] = obj[Symbol.iterator];\n\n        return result as T;\n      }\n\n      default: {\n        return undefined;\n      }\n    }\n  });\n}\n","import { cloneDeepWith } from './cloneDeepWith.ts';\n\n/**\n * Creates a deep clone of the given object.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to clone.\n * @returns {T} - A deep clone of the given object.\n *\n * @example\n * // Clone a primitive values\n * const num = 29;\n * const clonedNum = clone(num);\n * console.log(clonedNum); // 29\n * console.log(clonedNum === num) ; // true\n *\n * @example\n * // Clone an array\n * const arr = [1, 2, 3];\n * const clonedArr = clone(arr);\n * console.log(clonedArr); // [1, 2, 3]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an array with nested objects\n * const arr = [1, { a: 1 }, [1, 2, 3]];\n * const clonedArr = clone(arr);\n * arr[1].a = 2;\n * console.log(arr); // [2, { a: 2 }, [1, 2, 3]]\n * console.log(clonedArr); // [1, { a: 1 }, [1, 2, 3]]\n * console.log(clonedArr === arr); // false\n *\n * @example\n * // Clone an object\n * const obj = { a: 1, b: 'es-toolkit', c: [1, 2, 3] };\n * const clonedObj = clone(obj);\n * console.log(clonedObj); // { a: 1, b: 'es-toolkit', c: [1, 2, 3] }\n * console.log(clonedObj === obj); // false\n *\n * @example\n * // Clone an object with nested objects\n * const obj = { a: 1, b: { c: 1 } };\n * const clonedObj = clone(obj);\n * obj.b.c = 2;\n * console.log(obj); // { a: 1, b: { c: 2 } }\n * console.log(clonedObj); // { a: 1, b: { c: 1 } }\n * console.log(clonedObj === obj); // false\n */\nexport function cloneDeep<T>(obj: T): T {\n  return cloneDeepWith(obj);\n}\n","const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\\d*)$/;\n\nexport function isIndex(value: PropertyKey, length = Number.MAX_SAFE_INTEGER): boolean {\n  switch (typeof value) {\n    case 'number': {\n      return Number.isInteger(value) && value >= 0 && value < length;\n    }\n    case 'symbol': {\n      return false;\n    }\n    case 'string': {\n      return IS_UNSIGNED_INTEGER.test(value);\n    }\n  }\n}\n","import { getTag } from '../_internal/getTag.ts';\n\n/**\n * Checks if the given value is an arguments object.\n *\n * This function tests whether the provided value is an arguments object or not.\n * It returns `true` if the value is an arguments object, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an arguments object.\n *\n * @param {unknown} value - The value to test if it is an arguments object.\n * @returns {value is IArguments} `true` if the value is an arguments, `false` otherwise.\n *\n * @example\n * const args = (function() { return arguments; })();\n * const strictArgs = (function() { 'use strict'; return arguments; })();\n * const value = [1, 2, 3];\n *\n * console.log(isArguments(args)); // true\n * console.log(isArguments(strictArgs)); // true\n * console.log(isArguments(value)); // false\n */\nexport function isArguments(value?: unknown): value is IArguments {\n  return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n","import { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { isIndex } from '../_internal/isIndex.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Checks if a given path exists within an object.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @param {object} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has(object: unknown, path: PropertyKey | readonly PropertyKey[]): boolean;\n\n/**\n * Checks if a given path exists within an object.\n *\n * You can provide the path as a single property key, an array of property keys,\n * or a string representing a deep path.\n *\n * If the path is an index and the object is an array or an arguments object, the function will verify\n * if the index is valid and within the bounds of the array or arguments object, even if the array or\n * arguments object is sparse (i.e., not all indexes are defined).\n *\n * @param {object} object - The object to query.\n * @param {PropertyKey | PropertyKey[]} path - The path to check. This can be a single property key,\n *        an array of property keys, or a string representing a deep path.\n * @returns {boolean} Returns `true` if the path exists in the object, `false` otherwise.\n *\n * @example\n *\n * const obj = { a: { b: { c: 3 } } };\n *\n * has(obj, 'a'); // true\n * has(obj, ['a', 'b']); // true\n * has(obj, ['a', 'b', 'c']); // true\n * has(obj, 'a.b.c'); // true\n * has(obj, 'a.b.d'); // false\n * has(obj, ['a', 'b', 'c', 'd']); // false\n * has([], 0); // false\n * has([1, 2, 3], 2); // true\n * has([1, 2, 3], 5); // false\n */\nexport function has(object: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  let resolvedPath;\n\n  if (Array.isArray(path)) {\n    resolvedPath = path;\n  } else if (typeof path === 'string' && isDeepKey(path) && object?.[path] == null) {\n    resolvedPath = toPath(path);\n  } else {\n    resolvedPath = [path];\n  }\n\n  if (resolvedPath.length === 0) {\n    return false;\n  }\n\n  let current = object;\n\n  for (let i = 0; i < resolvedPath.length; i++) {\n    const key = resolvedPath[i];\n\n    // Check if the current key is a direct property of the current object\n    if (current == null || !Object.hasOwn(current, key)) {\n      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;\n\n      if (!isSparseIndex) {\n        return false;\n      }\n    }\n\n    current = current[key];\n  }\n\n  return true;\n}\n","import { isMatch } from './isMatch.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { cloneDeep } from '../object/cloneDeep.ts';\nimport { get } from '../object/get.ts';\nimport { has } from '../object/has.ts';\n\n/**\n * Creates a function that checks if a given target object matches a specific property value.\n *\n * The returned function takes a target object and determines if the property at the\n * specified path within the target object is equal to the given value.\n *\n * @param {PropertyKey | PropertyKey[]} property - The property path to check within the target object.\n *     This can be a single property key or an array of property keys.\n * @param {unknown} source - The value to compare against the property value in the target object.\n *\n * @returns {(target: unknown) => boolean} - A function that takes a target object and returns\n *     `true` if the property value at the given path in the target object matches the provided value,\n *     otherwise returns `false`.\n *\n * @example\n * // Using a single property key\n * const checkName = matchesProperty('name', 'Alice');\n * console.log(checkName({ name: 'Alice' })); // true\n * console.log(checkName({ name: 'Bob' })); // false\n *\n * // Using an array of property keys\n * const checkNested = matchesProperty(['address', 'city'], 'New York');\n * console.log(checkNested({ address: { city: 'New York' } })); // true\n * console.log(checkNested({ address: { city: 'Los Angeles' } })); // false\n */\nexport function matchesProperty(\n  property: PropertyKey | readonly PropertyKey[],\n  source: unknown\n): (target?: unknown) => boolean {\n  switch (typeof property) {\n    case 'object': {\n      if (Object.is(property?.valueOf(), -0)) {\n        property = '-0';\n      }\n      break;\n    }\n    case 'number': {\n      property = toKey(property);\n      break;\n    }\n  }\n\n  source = cloneDeep(source);\n\n  return function (target?: unknown) {\n    const result = get(target, property as PropertyKey | PropertyKey[]);\n\n    if (result === undefined) {\n      return has(target, property as PropertyKey | PropertyKey[]);\n    }\n\n    if (source === undefined) {\n      return result === undefined;\n    }\n\n    return isMatch(result, source);\n  };\n}\n","import { identity } from '../../function/identity.ts';\nimport { property } from '../object/property.ts';\nimport { matches } from '../predicate/matches.ts';\nimport { matchesProperty } from '../predicate/matchesProperty.ts';\n\n/**\n * Returns a `identity` function when `value` is `null` or `undefined`.\n *\n * @param {null} [value] - The value to convert to an iteratee.\n * @returns {<T>(value: T) => T} - Returns a `identity` function.\n *\n * @example\n * const func = iteratee();\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [{ a: 1 }, { a: 2 }, { a: 3 }]\n */\nexport function iteratee(value?: null): <T>(value: T) => T;\n\n/**\n * Returns a given `func` function when `value` is a `function`.\n *\n * @template {(...args: any[]) => unknown} F - The function type.\n * @param {F} func - The function to return.\n * @returns {F} - Returns the given function.\n *\n * @example\n * const func = iteratee((object) => object.a);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n */\nexport function iteratee<F extends (...args: any[]) => unknown>(func: F): F;\n\n/**\n * Creates a function that invokes `value` with the arguments of the created function.\n *\n * The created function returns the property value for a given element.\n *\n * @param {symbol | number | string | object} value - The value to convert to an iteratee.\n * @returns {(...args: any[]) => any} - Returns the new iteratee function.\n *\n * @example\n * const func = iteratee('a');\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee({ a: 1 });\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n *\n * const func = iteratee(['a', 1]);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n */\nexport function iteratee(value?: symbol | number | string | object): (...args: any[]) => any;\n\n/**\n * Creates a function that returns a value from an element in a collection.\n *\n * You can call `iteratee` with the following types of arguments:\n *\n * - **Function**: Returns the function as-is, which will be called with the element from the collection.\n * - **Property name**: Returns the value of the specified property from the element.\n * - **Property-value pair**: Returns a boolean indicating whether the element's property matches the given value.\n * - **Partial object**: Returns a boolean indicating whether the element matches the properties of the partial object.\n *\n * If you don't provide any arguments or pass `null`, this function will return a function that simply returns its input unchanged.\n *\n * @param {symbol | number | string | object | null | ((...args: any[]) => any)} value - The value to convert to an iteratee.\n * @returns {(...args: any[]) => unknown} - Returns the new iteratee function.\n * @example\n * const func = iteratee();\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [{ a: 1 }, { a: 2 }, { a: 3 }]\n *\n * const func = iteratee((object) => object.a);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee('a');\n * [{ a: 1 }, { a: 2 }, { a: 3 }].map(func) // => [1, 2, 3]\n *\n * const func = iteratee({ a: 1 });\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n *\n * const func = iteratee(['a', 1]);\n * [{ a: 1 }, { a: 2 }, { a: 3 }].find(func) // => { a: 1 }\n */\nexport function iteratee(\n  value?: symbol | number | string | object | null | ((...args: any[]) => unknown)\n): (...args: any[]) => any {\n  if (value == null) {\n    return identity;\n  }\n\n  switch (typeof value) {\n    case 'function': {\n      return value as any;\n    }\n    case 'object': {\n      if (Array.isArray(value) && value.length === 2) {\n        return matchesProperty(value[0], value[1]);\n      }\n\n      return matches(value);\n    }\n    case 'string':\n    case 'symbol':\n    case 'number': {\n      return property(value);\n    }\n  }\n}\n","/**\n * Check whether a value is a symbol.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `symbol`.\n *\n * @param {unknown} value The value to check.\n * @returns {value is symbol} Returns `true` if `value` is a symbol, else `false`.\n * @example\n * isSymbol(Symbol.iterator);\n * // => true\n *\n * isSymbol('abc');\n * // => false\n */\nexport function isSymbol(value?: unknown): value is symbol {\n  return typeof value === 'symbol' || value instanceof Symbol;\n}\n","import { isSymbol } from '../predicate/isSymbol.ts';\n\n/**\n * Converts `value` to a number.\n *\n * Unlike `Number()`, this function returns `NaN` for symbols.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toNumber(3.2); // => 3.2\n * toNumber(Number.MIN_VALUE); // => 5e-324\n * toNumber(Infinity); // => Infinity\n * toNumber('3.2'); // => 3.2\n * toNumber(Symbol.iterator); // => NaN\n * toNumber(NaN); // => NaN\n */\nexport function toNumber(value?: unknown): number {\n  if (isSymbol(value)) {\n    return NaN;\n  }\n\n  return Number(value);\n}\n","import { toNumber } from './toNumber.ts';\n\n/**\n * Converts `value` to a finite number.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toNumber(3.2); // => 3.2\n * toNumber(Number.MIN_VALUE); // => 5e-324\n * toNumber(Infinity); // => 1.7976931348623157e+308\n * toNumber('3.2'); // => 3.2\n * toNumber(Symbol.iterator); // => 0\n * toNumber(NaN); // => 0\n */\nexport function toFinite(value?: unknown): number {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n\n  value = toNumber(value);\n\n  if (value === Infinity || value === -Infinity) {\n    const sign = value < 0 ? -1 : 1;\n    return sign * Number.MAX_VALUE;\n  }\n\n  return value === value ? (value as number) : 0;\n}\n","import { toFinite } from './toFinite.ts';\n\n/**\n * Converts `value` to an integer.\n *\n * This function first converts `value` to a finite number. If the result has any decimal places,\n * they are removed by rounding down to the nearest whole number.\n *\n * @param {unknown} value - The value to convert.\n * @returns {number} Returns the number.\n *\n * @example\n * toInteger(3.2); // => 3\n * toInteger(Number.MIN_VALUE); // => 0\n * toInteger(Infinity); // => 1.7976931348623157e+308\n * toInteger('3.2'); // => 3\n * toInteger(Symbol.iterator); // => 0\n * toInteger(NaN); // => 0\n */\nexport function toInteger(value?: unknown): number {\n  const finite = toFinite(value);\n  const remainder = finite % 1;\n\n  return remainder ? finite - remainder : finite;\n}\n","import { isIndex } from './isIndex.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isObject } from '../predicate/isObject.ts';\nimport { eq } from '../util/eq.ts';\n\nexport function isIterateeCall(value: unknown, index: unknown, object: unknown): boolean {\n  if (!isObject(object)) {\n    return false;\n  }\n\n  if (\n    (typeof index === 'number' && isArrayLike(object) && isIndex(index) && index < object.length) ||\n    (typeof index === 'string' && index in object)\n  ) {\n    return eq((object as any)[index], value);\n  }\n\n  return false;\n}\n","/**\n * Checks if a given value is string.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `string`.\n *\n * @param {unknown} value The value to check if it is string.\n * @returns {value is string} Returns `true` if `value` is a string, else `false`.\n *\n * @example\n * const value1 = 'abc';\n * const value2 = 123;\n * const value3 = true;\n *\n * console.log(isString(value1)); // true\n * console.log(isString(value2)); // false\n * console.log(isString(value3)); // false\n */\n\nexport function isString(value?: unknown): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n","/**\n * Checks if the given value is an array.\n *\n * This function tests whether the provided value is an array or not.\n * It returns `true` if the value is an array, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to an array.\n *\n * @param {unknown} value - The value to test if it is an array.\n * @returns {value is any[]} `true` if the value is an array, `false` otherwise.\n *\n * @example\n * const value1 = [1, 2, 3];\n * const value2 = 'abc';\n * const value3 = () => {};\n *\n * console.log(isArray(value1)); // true\n * console.log(isArray(value2)); // false\n * console.log(isArray(value3)); // false\n */\nexport function isArray(value?: unknown): value is any[] {\n  return Array.isArray(value);\n}\n","import { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {ArrayLike<T> | null | undefined} value - The object to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>> | []} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(\n  value: ArrayLike<T> | null | undefined,\n  depth = 1 as D\n): Array<FlatArray<T[], D>> | [] {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  if (!isArrayLike(value)) {\n    return result;\n  }\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n      if (\n        currentDepth < flooredDepth &&\n        (Array.isArray(item) ||\n          Boolean(item?.[Symbol.isConcatSpreadable as keyof object]) ||\n          (item !== null && typeof item === 'object' && Object.prototype.toString.call(item) === '[object Arguments]'))\n      ) {\n        if (Array.isArray(item)) {\n          recursive(item, currentDepth + 1);\n        } else {\n          recursive(Array.from(item as T[]), currentDepth + 1);\n        }\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(Array.from(value), 0);\n\n  return result;\n}\n","import { identity } from '../../function/identity.ts';\nimport { range } from '../../math/range.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template K - The type of elements in the array.\n * @template T - The type of the array.\n * @param {T | null | undefined} array - The array to iterate over.\n * @param {(value: K, index: number, array: T) => unknown} [callback] - The function invoked for each element.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'array': The array 'forEach' was called upon.\n * @returns {T} Returns the original array.\n *\n * @example\n * forEach([1, 2, 3], (value, index, array) => console.log(value, index));\n * // Output:\n * // 1 0\n * // 2 1\n * // 3 2\n *\n */\nexport function forEach<T>(array: T[], callback?: (value: T, index: number, array: T[]) => unknown): T[];\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template K - The type of elements in the array.\n * @template T - The type of the array.\n * @param {T | null | undefined} array - The array to iterate over.\n * @param {(value: K, index: number, array: T) => unknown} [callback] - The function invoked for each element.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'array': The array 'forEach' was called upon.\n * @returns {T} Returns the original array.\n *\n * @example\n * forEach([1, 2, 3], (value, index, array) => console.log(value, index));\n * // Output:\n * // 1 0\n * // 2 1\n * // 3 2\n *\n */\nexport function forEach<T>(\n  array: readonly T[],\n  callback?: (value: T, index: number, array: T[]) => unknown\n): readonly T[];\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template T - The type of string.\n * @param {T | null | undefined} string - The string to iterate over\n * @param {(value: T, index: number, string: T) => unknown} [callback] - The function invoked for each char.\n * The callback function receives three arguments:\n *  - 'char': The current char being processed in the string.\n *  - 'index': The index of the current char being processed in the string.\n *  - 'string': The string 'forEach' was called upon.\n * @returns {T} Returns the original string.\n *\n * @example\n * forEach('abc', (char, index, string) => console.log(char, index));\n * // Output:\n * // 'a' 0\n * // 'b' 1\n * // 'c' 2\n */\nexport function forEach<T extends string | null | undefined>(\n  string: T,\n  callback?: (char: string, index: number, string: string) => unknown\n): T;\n\n/**\n * Iterates over each element of the array invoking the provided callback function for each element.\n *\n * @template T - The type of elements in the array.\n * @param { ArrayLike<T> } array - The array to iterate over.\n * @param {(value: T, index: number, array: ArrayLike<T>) => unknown} [callback] - The function invoked for each element.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'array': The array 'forEach' was called upon.\n * @returns {T} Returns the original array.\n *\n * @example\n * forEach([1, 2, 3], (value, index, array) => console.log(value, index));\n * // Output:\n * // 1 0\n * // 2 1\n * // 3 2\n *\n */\nexport function forEach<T>(\n  array: ArrayLike<T>,\n  callback?: (value: T, index: number, array: ArrayLike<T>) => unknown\n): ArrayLike<T>;\n\n/**\n * Iterates over each element of the object invoking the provided callback function for each property.\n *\n * @template T - The type of object.\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} [callback] - The function invoked for each property.\n * The callback function receives three arguments:\n *  - 'value': The current property being processed in the object.\n *  - 'key': The key of the current property being processed in the object.\n *  - 'object': The object 'forEach' was called upon.\n * @returns {T} Returns the original object.\n *\n * @example\n * forEach({'a': 1, 'b': 2 }, (value, key, object) => console.log(value, key));\n * // Output:\n * // 1 'a'\n * // 2 'b'\n */\nexport function forEach<T extends object | null | undefined>(\n  object: T,\n  callback?: (value: T[keyof T], key: keyof T, object: T) => unknown\n): T;\n\n/**\n * Iterates over each element of the object invoking the provided callback function for each property.\n *\n * @template T - The type of object.\n * @param {T} object - The object to iterate over.\n * @param {(value: T[keyof T], key: keyof T, object: T) => unknown} [callback] - The function invoked for each property.\n * The callback function receives three arguments:\n *  - 'value': The current property being processed in the object.\n *  - 'key': The key of the current property being processed in the object.\n *  - 'object': The object 'forEach' was called upon.\n * @returns {T} Returns the original object.\n *\n * @example\n * forEach({'a': 1, 'b': 2 }, (value, key, object) => console.log(value, key));\n * // Output:\n * // 1 'a'\n * // 2 'b'\n */\nexport function forEach<T>(\n  collection: ArrayLike<T> | Record<any, any> | string | null | undefined,\n  callback: (item: any, index: any, arr: any) => unknown = identity\n): ArrayLike<T> | Record<any, any> | string | null | undefined {\n  if (!collection) {\n    return collection;\n  }\n\n  const keys: PropertyKey[] =\n    isArrayLike(collection) || Array.isArray(collection) ? range(0, collection.length) : Object.keys(collection);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = (collection as any)[key];\n\n    const result = callback(value, key, collection);\n\n    if (result === false) {\n      break;\n    }\n  }\n\n  return collection;\n}\n","import { head as headToolkit } from '../../array/head.ts';\nimport { toArray } from '../_internal/toArray.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | undefined | null} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: ArrayLike<T> | undefined | null): T | undefined {\n  if (!isArrayLike(arr)) {\n    return undefined;\n  }\n  return headToolkit(toArray(arr));\n}\n","/**\n * Returns the first element of an array.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {[T, ...T[]]} arr - A non-empty array from which to get the first element.\n * @returns {T} The first element of the array.\n *\n * @example\n * const arr = [1, 2, 3];\n * const firstElement = head(arr);\n * // firstElement will be 1\n */\nexport function head<T>(arr: readonly [T, ...T[]]): T;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly T[]): T | undefined;\n\n/**\n * Returns the first element of an array or `undefined` if the array is empty.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n","import { uniq as uniqToolkit } from '../../array/uniq.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\n\n/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | null | undefined} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: ArrayLike<T> | null | undefined): T[] {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n  return uniqToolkit(Array.from(arr));\n}\n","import { last } from './last.ts';\nimport { intersectionWith as intersectionWithToolkit } from '../../array/intersectionWith.ts';\nimport { uniq as uniqToolkit } from '../array/uniq.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the first array.\n * @template U - The type of elements in the second array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {U[]} secondArr - The second array to compare.\n * @param {(x: T, y: U) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n *\n * @example\n * const array1 = [\n *   { id: 1, name: 'jane' },\n *   { id: 2, name: 'amy' },\n *   { id: 3, name: 'michael' },\n * ];\n * const array2 = [2, 4];\n * const areItemsEqual = (a, b) => a.id === b;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2, name: 'amy' }] since this element has a matching id that is equal to seconds array's element.\n */\nexport function intersectionWith<T, U>(\n  firstArr: ArrayLike<T> | null | undefined,\n  secondArr: ArrayLike<U> | null | undefined,\n  areItemsEqual: (x: T, y: U) => boolean\n): T[];\n/**\n * Returns the intersection of three arrays based on a custom equality function.\n *\n * @template T - The type of elements in the first array\n * @template U - The type of elements in the second array\n * @template V - The type of elements in the third array\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {ArrayLike<U> | null | undefined} secondArr - The second array to compare\n * @param {ArrayLike<V> | null | undefined} thirdArr - The third array to compare\n * @param {(x: T, y: U | V) => boolean} areItemsEqual - Custom equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const arr3 = [{id: 2}, {id: 4}];\n * const result = intersectionWith(arr1, arr2, arr3, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T, U, V>(\n  firstArr: ArrayLike<T> | null | undefined,\n  secondArr: ArrayLike<U> | null | undefined,\n  thirdArr: ArrayLike<V> | null | undefined,\n  areItemsEqual: (x: T, y: U | V) => boolean\n): T[];\n\n/**\n * Returns the intersection of four arrays based on a custom equality function.\n *\n * @template T - The type of elements in the first array\n * @template U - The type of elements in the second array\n * @template V - The type of elements in the third array\n * @template W - The type of elements in the fourth array\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {ArrayLike<U> | null | undefined} secondArr - The second array to compare\n * @param {ArrayLike<V> | null | undefined} thirdArr - The third array to compare\n * @param {ArrayLike<V> | null | undefined} fourthArr - The fourth array to compare\n * @param {(x: T, y: U | V | W) => boolean} areItemsEqual - Custom equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const arr3 = [{id: 2}, {id: 4}];\n * const arr4 = [{id: 2}, {id: 5}];\n * const result = intersectionWith(arr1, arr2, arr3, arr4, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T, U, V, W>(\n  firstArr: ArrayLike<T> | null | undefined,\n  secondArr: ArrayLike<U> | null | undefined,\n  thirdArr: ArrayLike<V> | null | undefined,\n  fourthArr: ArrayLike<V> | null | undefined,\n  areItemsEqual: (x: T, y: U | V | W) => boolean\n): T[];\n\n/**\n * Returns the intersection of multiple arrays based on a custom equality function.\n *\n * @template T - The type of elements in the arrays\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {...(ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean))} otherArrs - Additional arrays and optional equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const arr3 = [{id: 2}, {id: 4}];\n * const result = intersectionWith(arr1, arr2, arr3, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T>(\n  firstArr: ArrayLike<T> | null | undefined,\n  ...otherArrs: Array<ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean)>\n): T[];\n\n/**\n * Returns the intersection of multiple arrays based on a custom equality function.\n *\n * @template T - The type of elements in the arrays\n * @param {ArrayLike<T> | null | undefined} firstArr - The first array to compare\n * @param {...(ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean))} otherArrs - Additional arrays and optional equality function\n * @returns {T[]} Elements from first array that match in all arrays\n *\n * @example\n * const arr1 = [{id: 1}, {id: 2}];\n * const arr2 = [{id: 2}, {id: 3}];\n * const result = intersectionWith(arr1, arr2, (a, b) => a.id === b.id);\n * // result is [{id: 2}]\n */\nexport function intersectionWith<T>(\n  firstArr: ArrayLike<T> | null | undefined,\n  ...otherArrs: Array<ArrayLike<T> | null | undefined | ((x: T, y: T) => boolean)>\n): T[] {\n  console.log(firstArr);\n\n  if (firstArr == null) {\n    return [];\n  }\n\n  const _comparator = last(otherArrs);\n  let comparator = eq as (x: T, y: T) => boolean;\n  let uniq: (arr: T[]) => T[] = uniqToolkit;\n\n  if (typeof _comparator === 'function') {\n    comparator = _comparator;\n    uniq = uniqPreserve0;\n    otherArrs.pop();\n  }\n\n  let result = uniq(Array.from(firstArr));\n\n  for (let i = 0; i < otherArrs.length; ++i) {\n    const otherArr = otherArrs[i] as ArrayLike<T>;\n\n    if (otherArr == null) {\n      return [];\n    }\n\n    result = intersectionWithToolkit(result, Array.from(otherArr), comparator);\n  }\n\n  return result;\n}\n\n/**\n * This function is to preserve the sign of `-0`, which is a behavior in lodash.\n */\nfunction uniqPreserve0<T>(arr: T[]): T[] {\n  const result = [];\n  const added = new Set();\n\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n\n    if (added.has(item)) {\n      continue;\n    }\n\n    result.push(item);\n    added.add(item);\n  }\n\n  return result;\n}\n","function getPriority(a: unknown): 0 | 1 | 2 | 3 | 4 {\n  if (typeof a === 'symbol') {\n    return 1;\n  }\n\n  if (a === null) {\n    return 2;\n  }\n\n  if (a === undefined) {\n    return 3;\n  }\n\n  if (a !== a) {\n    return 4;\n  }\n\n  return 0;\n}\n\nexport const compareValues = <V>(a: V, b: V, order: string) => {\n  if (a !== b) {\n    // If both values are strings, compare them using localeCompare.\n    if (typeof a === 'string' && typeof b === 'string') {\n      return order === 'desc' ? b.localeCompare(a) : a.localeCompare(b);\n    }\n\n    const aPriority = getPriority(a);\n    const bPriority = getPriority(b);\n\n    // If both values are of the same priority and are normal values, compare them.\n    if (aPriority === bPriority && aPriority === 0) {\n      if (a < b) {\n        return order === 'desc' ? 1 : -1;\n      }\n\n      if (a > b) {\n        return order === 'desc' ? -1 : 1;\n      }\n    }\n\n    return order === 'desc' ? bPriority - aPriority : aPriority - bPriority;\n  }\n\n  return 0;\n};\n","import { isSymbol } from '../predicate/isSymbol.ts';\n\n/**  Matches any deep property path. (e.g. `a.b[0].c`)*/\nconst regexIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n/**  Matches any word character (alphanumeric & underscore).*/\nconst regexIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path. (It's ok that the `value` is not in the keys of the `object`)\n * @param {unknown} value The value to check.\n * @param {unknown} object The object to query.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n *\n * @example\n * isKey('a', { a: 1 });\n * // => true\n *\n * isKey('a.b', { a: { b: 2 } });\n * // => false\n */\nexport function isKey(value?: unknown, object?: unknown): value is PropertyKey {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  if (typeof value === 'number' || typeof value === 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n\n  return (\n    (typeof value === 'string' && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value))) ||\n    (object != null && Object.hasOwn(object, value as PropertyKey))\n  );\n}\n","import { compareValues } from '../_internal/compareValues.ts';\nimport { isKey } from '../_internal/isKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\nexport type Criterion<T> = ((item: T) => unknown) | PropertyKey | PropertyKey[] | null | undefined;\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of criteria to sort by, and an array of order directions.\n * It returns the sorted array, ordering by each key according to its corresponding direction ('asc' for ascending or 'desc' for descending).\n * If values for a key are equal, it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {ArrayLike<T> | object | null | undefined} collection - The array of objects to be sorted.\n * @param {Criterion<T> | Array<Criterion<T>>} criteria - An array of criteria (property names or property paths or custom key functions) to sort by.\n * @param {unknown | unknown[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\n * @param {unknown} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {T[]} - The sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = orderBy(users, ['user', (item) => item.age], ['asc', 'desc']);\n * // result will be:\n * // [\n * //   { user: 'barney', age: 36 },\n * //   { user: 'barney', age: 34 },\n * //   { user: 'fred', age: 48 },\n * //   { user: 'fred', age: 40 },\n * // ]\n */\nexport function orderBy<T = any>(\n  collection: ArrayLike<T> | object | null | undefined,\n  criteria?: Criterion<T> | Array<Criterion<T>>,\n  orders?: unknown | unknown[],\n  guard?: unknown\n): T[] {\n  if (collection == null) {\n    return [];\n  }\n\n  orders = guard ? undefined : orders;\n\n  if (!Array.isArray(collection)) {\n    collection = Object.values(collection);\n  }\n\n  if (!Array.isArray(criteria)) {\n    criteria = criteria == null ? [null] : [criteria];\n  }\n  if (criteria.length === 0) {\n    criteria = [null];\n  }\n\n  if (!Array.isArray(orders)) {\n    orders = orders == null ? [] : [orders];\n  }\n\n  // For Object('desc') case\n  orders = (orders as unknown[]).map(order => String(order));\n\n  const getValueByNestedPath = (object: object, path: PropertyKey[]) => {\n    let target: object = object;\n\n    for (let i = 0; i < path.length && target != null; ++i) {\n      target = target[path[i] as keyof typeof target];\n    }\n\n    return target;\n  };\n\n  const getValueByCriterion = (criterion: Criterion<T> | { key: PropertyKey; path: string[] }, object: T) => {\n    if (object == null || criterion == null) {\n      return object;\n    }\n\n    if (typeof criterion === 'object' && 'key' in criterion) {\n      if (Object.hasOwn(object, criterion.key)) {\n        return object[criterion.key as keyof typeof object];\n      }\n\n      return getValueByNestedPath(object, criterion.path);\n    }\n\n    if (typeof criterion === 'function') {\n      return criterion(object);\n    }\n\n    if (Array.isArray(criterion)) {\n      return getValueByNestedPath(object, criterion);\n    }\n\n    if (typeof object === 'object') {\n      return object[criterion as keyof typeof object];\n    }\n\n    return object;\n  };\n\n  // Prepare all cases for criteria\n  const preparedCriteria = criteria.map(criterion => {\n    // lodash handles a array with one element as a single criterion\n    if (Array.isArray(criterion) && criterion.length === 1) {\n      criterion = criterion[0];\n    }\n\n    if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey(criterion)) {\n      return criterion;\n    }\n\n    // If criterion is not key, it has possibility to be a deep path. So we have to prepare both cases.\n    return { key: criterion, path: toPath(criterion) };\n  });\n\n  // Array.prototype.sort() always shifts the `undefined` values to the end of the array. So we have to prevent it by using a wrapper object.\n  const preparedCollection = (collection as T[]).map(item => ({\n    original: item,\n    criteria: preparedCriteria.map(criterion => getValueByCriterion(criterion, item)),\n  }));\n\n  return preparedCollection\n    .slice()\n    .sort((a, b) => {\n      for (let i = 0; i < preparedCriteria.length; i++) {\n        const comparedResult = compareValues(a.criteria[i], b.criteria[i], (orders as string[])[i]);\n\n        if (comparedResult !== 0) {\n          return comparedResult;\n        }\n      }\n\n      return 0;\n    })\n    .map(item => item.original);\n}\n","/**\n * Checks if the value is NaN.\n *\n * @param {unknown} value - The value to check.\n * @returns {value is typeof NaN} `true` if the value is NaN, `false` otherwise.\n *\n * @example\n * isNaN(NaN); // true\n * isNaN(0); // false\n * isNaN('NaN'); // false\n * isNaN(undefined); // false\n */\nexport function isNaN(value?: unknown): value is typeof NaN {\n  return Number.isNaN(value);\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x?: unknown): x is null | undefined {\n  return x == null;\n}\n","import { isNull, isUndefined } from '../../predicate';\nimport { isNaN } from '../predicate/isNaN';\nimport { isNil } from '../predicate/isNil';\nimport { isSymbol } from '../predicate/isSymbol';\n\ntype Iteratee<T, R> = (value: T) => R;\n\nconst MAX_ARRAY_LENGTH = 4294967295;\nconst MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n/**\n * This method is like `sortedIndex` except that it accepts `iteratee`\n * which is invoked for `value` and each element of `array` to compute their\n * sort ranking. The iteratee is invoked with one argument: (value).\n *\n * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.\n * @param {T} value The value to evaluate.\n * @param {(value: T) => R} iteratee The iteratee invoked per element.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n * const objects = [{ 'n': 4 }, { 'n': 5 }]\n * sortedIndexBy(objects, { 'n': 4 }, ({ n }) => n)\n * // => 0\n */\nexport function sortedIndexBy<T, R>(\n  array: ArrayLike<T> | null | undefined,\n  value: T,\n  iteratee?: Iteratee<T, R>,\n  retHighest?: boolean\n): number {\n  let low = 0;\n  let high = array == null ? 0 : array.length;\n  if (high === 0 || isNil(array)) {\n    return 0;\n  }\n\n  const transformedValue = iteratee?.(value);\n\n  const valIsNaN = isNaN(transformedValue);\n  const valIsNull = isNull(transformedValue);\n  const valIsSymbol = isSymbol(transformedValue);\n  const valIsUndefined = isUndefined(transformedValue);\n\n  while (low < high) {\n    let setLow: boolean;\n    const mid = Math.floor((low + high) / 2);\n    const computed = iteratee?.(array[mid]);\n\n    const othIsDefined = !isUndefined(computed);\n    const othIsNull = isNull(computed);\n    const othIsReflexive = !isNaN(computed);\n    const othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? computed! <= transformedValue : computed! < transformedValue;\n    }\n\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return Math.min(high, MAX_ARRAY_INDEX);\n}\n","/**\n * Checks if a given value is a number.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `number`.\n *\n * @param {unknown} value The value to check if it is a number.\n * @returns {value is number} Returns `true` if `value` is a number, else `false`.\n *\n * @example\n * const value1 = 123;\n * const value2 = 'abc';\n * const value3 = true;\n *\n * console.log(isNumber(value1)); // true\n * console.log(isNumber(value2)); // false\n * console.log(isNumber(value3)); // false\n */\nexport function isNumber(value?: unknown): value is number {\n  return typeof value === 'number' || value instanceof Number;\n}\n","import { isIndex } from '../_internal/isIndex.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to modify.\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T>(obj: object, path: PropertyKey | readonly PropertyKey[], value: unknown): T;\n/**\n * Sets the value at the specified path of the given object. If any part of the path does not exist, it will be created.\n *\n * @template T - The type of the object.\n * @param {T} obj - The object to modify.\n * @param {PropertyKey | PropertyKey[]} path - The path of the property to set.\n * @param {any} value - The value to set.\n * @returns {T} - The modified object.\n *\n * @example\n * // Set a value in a nested object\n * const obj = { a: { b: { c: 3 } } };\n * set(obj, 'a.b.c', 4);\n * console.log(obj.a.b.c); // 4\n *\n * @example\n * // Set a value in an array\n * const arr = [1, 2, 3];\n * set(arr, 1, 4);\n * console.log(arr[1]); // 4\n *\n * @example\n * // Create non-existent path and set value\n * const obj = {};\n * set(obj, 'a.b.c', 4);\n * console.log(obj); // { a: { b: { c: 4 } } }\n */\nexport function set<T extends object>(obj: T, path: PropertyKey | readonly PropertyKey[], value: unknown): T {\n  const resolvedPath = Array.isArray(path) ? path : typeof path === 'string' ? toPath(path) : [path];\n\n  let current: any = obj;\n\n  for (let i = 0; i < resolvedPath.length - 1; i++) {\n    const key = resolvedPath[i];\n    const nextKey = resolvedPath[i + 1];\n\n    if (current[key] == null) {\n      current[key] = isIndex(nextKey) ? [] : {};\n    }\n\n    current = current[key];\n  }\n\n  const lastKey = resolvedPath[resolvedPath.length - 1];\n  current[lastKey] = value;\n\n  return obj;\n}\n","/**\n * Attempts to execute a function with the provided arguments.\n * If the function throws an error, it catches the error and returns it.\n * If the caught error is not an instance of Error, it wraps it in a new Error.\n *\n * @param {F} func - The function to be executed.\n * @param {...Parameters<F>} args - The arguments to pass to the function.\n * @returns {ReturnType<F> | Error} The return value of the function if successful, or an Error if an exception is thrown.\n *\n * @template F - The type of the function being attempted.\n *\n * @example\n * // Example 1: Successful execution\n * const result = attempt((x, y) => x + y, 2, 3);\n * console.log(result); // Output: 5\n *\n * @example\n * // Example 2: Function throws an error\n * const errorResult = attempt(() => {\n *   throw new Error(\"Something went wrong\");\n * });\n * console.log(errorResult); // Output: Error: Something went wrong\n *\n * @example\n * // Example 3: Non-Error thrown\n * const nonErrorResult = attempt(() => {\n *   throw \"This is a string error\";\n * });\n * console.log(nonErrorResult); // Output: Error: This is a string error\n */\nexport function attempt<F extends (...args: any[]) => any>(func: F, ...args: Parameters<F>): ReturnType<F> | Error {\n  try {\n    return func(...args);\n  } catch (e: any) {\n    return e instanceof Error ? e : new Error(e);\n  }\n}\n","/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg` and `partials` prepended to the arguments it receives.\n *\n * The `bind.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: Unlike native `Function#bind`, this method doesn't set the `length` property of bound functions.\n *\n * @template F - The type of the function to bind.\n * @param {F} func - The function to bind.\n * @param {unknown} thisObj - The `this` binding of `func`.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {F} - Returns the new bound function.\n *\n * @example\n * function greet(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * }\n * const object = { user: 'fred' };\n * let bound = bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * bound = bind(greet, object, bind.placeholder, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nexport function bind<F extends (...args: any[]) => any>(func: F, thisObj?: unknown, ...partialArgs: any[]): F {\n  const bound = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bind.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof bound) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...args);\n    }\n\n    return func.apply(thisObj, args);\n  };\n\n  return bound as any as F;\n}\n\nconst bindPlaceholder: unique symbol = Symbol('bind.placeholder');\nbind.placeholder = bindPlaceholder;\n","/**\n * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.\n *\n * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.\n *\n * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * @template T - The type of the object to bind.\n * @template K - The type of the key to bind.\n * @param {T} object - The object to invoke the method on.\n * @param {K} key - The key of the method.\n * @param {...any} partialArgs - The arguments to be partially applied.\n * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.\n *\n * @example\n * const object = {\n *   user: 'fred',\n *   greet: function (greeting, punctuation) {\n *     return greeting + ' ' + this.user + punctuation;\n *   },\n * };\n *\n * let bound = bindKey(object, 'greet', 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * object.greet = function (greeting, punctuation) {\n *   return greeting + 'ya ' + this.user + punctuation;\n * };\n *\n * bound('!');\n * // => 'hiya fred!'\n *\n * // Bound with placeholders.\n * bound = bindKey(object, 'greet', bindKey.placeholder, '!');\n * bound('hi');\n * // => 'hiya fred!'\n */\nexport function bindKey<T extends Record<PropertyKey, any>, K extends keyof T>(\n  object: T,\n  key: K,\n  ...partialArgs: any[]\n): T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never {\n  const bound = function (this: any, ...providedArgs: any[]) {\n    const args: any[] = [];\n\n    // Populate args by merging partialArgs and providedArgs.\n    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);\n    // we have args with [1, 2, 3, 4].\n    let startIndex = 0;\n\n    for (let i = 0; i < partialArgs.length; i++) {\n      const arg = partialArgs[i];\n\n      if (arg === bindKey.placeholder) {\n        args.push(providedArgs[startIndex++]);\n      } else {\n        args.push(arg);\n      }\n    }\n\n    for (let i = startIndex; i < providedArgs.length; i++) {\n      args.push(providedArgs[i]);\n    }\n\n    if (this instanceof bound) {\n      return new object[key](...args);\n    }\n\n    // eslint-disable-next-line prefer-spread\n    return object[key].apply(object, args);\n  };\n\n  return bound as any;\n}\n\nconst bindKeyPlaceholder: unique symbol = Symbol('bindKey.placeholder');\nbindKey.placeholder = bindKeyPlaceholder;\n","/**\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\n * The arity of `func` may be specified if `func.length` is not sufficient.\n *\n * The `curry.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of curried functions.\n *\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\n * @returns {((...args: any[]) => any) & { placeholder: typeof curry.placeholder }} - Returns the new curried function.\n *\n * @example\n * const abc = function(a, b, c) {\n *   return Array.from(arguments);\n * };\n *\n * let curried = curry(abc);\n *\n * curried(1)(2)(3);\n * // => [1, 2, 3]\n *\n * curried(1, 2)(3);\n * // => [1, 2, 3]\n *\n * curried(1, 2, 3);\n * // => [1, 2, 3]\n *\n * // Curried with placeholders.\n * curried(1)(curry.placeholder, 3)(2);\n * // => [1, 2, 3]\n *\n * // Curried with arity.\n * curried = curry(abc, 2);\n *\n * curried(1)(2);\n * // => [1, 2]\n */\nexport function curry(\n  func: (...args: any[]) => any,\n  arity: number = func.length,\n  guard?: unknown\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\n  arity = guard ? func.length : arity;\n  arity = Number.parseInt(arity as any, 10);\n  if (Number.isNaN(arity) || arity < 1) {\n    arity = 0;\n  }\n\n  const wrapper = function (this: any, ...partialArgs: any[]) {\n    const holders = partialArgs.filter(item => item === curry.placeholder);\n    const length = partialArgs.length - holders.length;\n    if (length < arity) {\n      return makeCurry(func, arity - length, partialArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...partialArgs);\n    }\n    return func.apply(this, partialArgs);\n  };\n\n  wrapper.placeholder = curryPlaceholder;\n\n  return wrapper;\n}\n\nfunction makeCurry(\n  func: (...args: any[]) => any,\n  arity: number,\n  partialArgs: any[]\n): ((...args: any[]) => any) & { placeholder: typeof curry.placeholder } {\n  function wrapper(this: any, ...providedArgs: any[]) {\n    const holders = providedArgs.filter(item => item === curry.placeholder);\n    const length = providedArgs.length - holders.length;\n    providedArgs = composeArgs(providedArgs, partialArgs);\n    if (length < arity) {\n      return makeCurry(func, arity - length, providedArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...providedArgs);\n    }\n    return func.apply(this, providedArgs);\n  }\n  wrapper.placeholder = curryPlaceholder;\n  return wrapper;\n}\n\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\n  const args = [];\n  let startIndex = 0;\n  for (let i = 0; i < partialArgs.length; i++) {\n    const arg = partialArgs[i];\n\n    if (arg === curry.placeholder && startIndex < providedArgs.length) {\n      args.push(providedArgs[startIndex++]);\n    } else {\n      args.push(arg);\n    }\n  }\n  for (let i = startIndex; i < providedArgs.length; i++) {\n    args.push(providedArgs[i]);\n  }\n  return args;\n}\n\nconst curryPlaceholder: unique symbol = Symbol('curry.placeholder');\ncurry.placeholder = curryPlaceholder;\n","/**\n * Creates a function that accepts arguments of `func` and either invokes `func` returning its result, if at least `arity` number of arguments have been provided, or returns a function that accepts the remaining `func` arguments, and so on.\n * The arity of `func` may be specified if `func.length` is not sufficient.\n *\n * Unlike `curry`, this function curries the function from right to left.\n *\n * The `curryRight.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.\n *\n * Note: This method doesn't set the `length` property of curried functions.\n *\n * @param {(...args: any[]) => any} func - The function to curry.\n * @param {number=func.length} arity - The arity of func.\n * @param {unknown} guard - Enables use as an iteratee for methods like `Array#map`.\n * @returns {((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder }} - Returns the new curried function.\n *\n * @example\n * const abc = function(a, b, c) {\n *   return Array.from(arguments);\n * };\n *\n * let curried = curryRight(abc);\n *\n * curried(3)(2)(1);\n * // => [1, 2, 3]\n *\n * curried(2, 3)(1);\n * // => [1, 2, 3]\n *\n * curried(1, 2, 3);\n * // => [1, 2, 3]\n *\n * // Curried with placeholders.\n * curried(3)(curryRight.placeholder, 2)(1);\n * // => [1, 2, 3]\n *\n * // Curried with arity.\n * curried = curryRight(abc, 2);\n *\n * curried(2)(1);\n * // => [1, 2]\n */\nexport function curryRight(\n  func: (...args: any[]) => any,\n  arity: number = func.length,\n  guard?: unknown\n): ((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder } {\n  arity = guard ? func.length : arity;\n  arity = Number.parseInt(arity as any, 10);\n  if (Number.isNaN(arity) || arity < 1) {\n    arity = 0;\n  }\n\n  const wrapper = function (this: any, ...partialArgs: any[]) {\n    const holders = partialArgs.filter(item => item === curryRight.placeholder);\n    const length = partialArgs.length - holders.length;\n    if (length < arity) {\n      return makeCurryRight(func, arity - length, partialArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...partialArgs);\n    }\n    return func.apply(this, partialArgs);\n  };\n\n  wrapper.placeholder = curryRightPlaceholder;\n\n  return wrapper;\n}\n\nfunction makeCurryRight(\n  func: (...args: any[]) => any,\n  arity: number,\n  partialArgs: any[]\n): ((...args: any[]) => any) & { placeholder: typeof curryRight.placeholder } {\n  function wrapper(this: any, ...providedArgs: any[]) {\n    const holders = providedArgs.filter(item => item === curryRight.placeholder);\n    const length = providedArgs.length - holders.length;\n    providedArgs = composeArgs(providedArgs, partialArgs);\n    if (length < arity) {\n      return makeCurryRight(func, arity - length, providedArgs);\n    }\n    if (this instanceof wrapper) {\n      // @ts-expect-error - fn is a constructor\n      return new func(...providedArgs);\n    }\n    return func.apply(this, providedArgs);\n  }\n  wrapper.placeholder = curryRightPlaceholder;\n  return wrapper;\n}\n\nfunction composeArgs(providedArgs: any[], partialArgs: any[]): any[] {\n  const placeholderLength = partialArgs.filter(arg => arg === curryRight.placeholder).length;\n  const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);\n  const args: any[] = [];\n\n  let providedIndex = 0;\n  for (let i = 0; i < rangeLength; i++) {\n    args.push(providedArgs[providedIndex++]);\n  }\n  for (let i = 0; i < partialArgs.length; i++) {\n    const arg = partialArgs[i];\n\n    if (arg === curryRight.placeholder) {\n      if (providedIndex < providedArgs.length) {\n        args.push(providedArgs[providedIndex++]);\n      } else {\n        args.push(arg);\n      }\n    } else {\n      args.push(arg);\n    }\n  }\n  return args;\n}\n\nconst curryRightPlaceholder: unique symbol = Symbol('curryRight.placeholder');\ncurryRight.placeholder = curryRightPlaceholder;\n","import { debounce as debounceToolkit } from '../../function/debounce.ts';\n\ninterface DebounceOptions {\n  /**\n   * An optional AbortSignal to cancel the debounced function.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * If `true`, the function will be invoked on the leading edge of the timeout.\n   * @default false\n   */\n  leading?: boolean;\n\n  /**\n   * If `true`, the function will be invoked on the trailing edge of the timeout.\n   * @default true\n   */\n  trailing?: boolean;\n\n  /**\n   * The maximum time `func` is allowed to be delayed before it's invoked.\n   * @default Infinity\n   */\n  maxWait?: number;\n}\n\nexport interface DebouncedFunction<F extends (...args: any[]) => any> {\n  (...args: Parameters<F>): ReturnType<F> | undefined;\n  cancel(): void;\n  flush(): void;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * You can set the debounced function to run at the start (`leading`) or end (`trailing`) of the delay period.\n * If `leading` is true, the function runs immediately on the first call.\n * If `trailing` is true, the function runs after `debounceMs` milliseconds have passed since the last call.\n * If both `leading` and `trailing` are true, the function runs at both the start and end, but it must be called at least twice within `debounceMs` milliseconds for this to happen\n * (since one debounced function call cannot trigger the function twice).\n *\n * You can also set a `maxWait` time, which is the maximum time the function is allowed to be delayed before it is called.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.\n * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.\n * @param {number} options.maxWait - The maximum time `func` is allowed to be delayed before it's invoked.\n * @returns A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => any>(\n  func: F,\n  debounceMs = 0,\n  options: DebounceOptions = {}\n): DebouncedFunction<F> {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  const { signal, leading = false, trailing = true, maxWait } = options;\n\n  const edges = Array(2);\n\n  if (leading) {\n    edges[0] = 'leading';\n  }\n\n  if (trailing) {\n    edges[1] = 'trailing';\n  }\n\n  let result: ReturnType<F> | undefined = undefined;\n  let pendingAt: number | null = null;\n\n  const _debounced = debounceToolkit(\n    function (this: any, ...args: Parameters<F>) {\n      result = func.apply(this, args);\n      pendingAt = null;\n    },\n    debounceMs,\n    { signal, edges }\n  );\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    if (maxWait != null) {\n      if (pendingAt === null) {\n        pendingAt = Date.now();\n      } else {\n        if (Date.now() - pendingAt >= maxWait) {\n          result = func.apply(this, args);\n          pendingAt = Date.now();\n\n          _debounced.cancel();\n          _debounced.schedule();\n\n          return result;\n        }\n      }\n    }\n\n    _debounced.apply(this, args);\n    return result;\n  };\n\n  const flush = () => {\n    _debounced.flush();\n    return result;\n  };\n\n  debounced.cancel = _debounced.cancel;\n  debounced.flush = flush;\n\n  return debounced;\n}\n","export function decimalAdjust(\n  type: 'round' | 'floor' | 'ceil',\n  number: number | string,\n  precision: number | string = 0\n): number {\n  number = Number(number);\n  if (Object.is(number, -0)) {\n    number = '-0';\n  }\n  precision = Math.min(Number.parseInt(precision as string, 10), 292);\n  if (precision) {\n    const [magnitude, exponent = 0] = number.toString().split('e');\n    let adjustedValue: string | number = Math[type](Number(`${magnitude}e${Number(exponent) + precision}`));\n    if (Object.is(adjustedValue, -0)) {\n      adjustedValue = '-0';\n    }\n    const [newMagnitude, newExponent = 0] = adjustedValue.toString().split('e');\n    return Number(`${newMagnitude}e${Number(newExponent) - precision}`);\n  }\n  return Math[type](Number(number));\n}\n","import { clamp as clampToolkit } from '../../math/clamp.ts';\n\n/**\n * Clamps a number within the inclusive upper bound.\n *\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified upper bound.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n */\nexport function clamp(value: number, maximum: number): number;\n\n/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, minimum: number, maximum: number): number;\n\n/**\n * Clamps a number within the specified bounds.\n *\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (Number.isNaN(bound1)) {\n    bound1 = 0;\n  }\n\n  if (Number.isNaN(bound2)) {\n    bound2 = 0;\n  }\n\n  return clampToolkit(value, bound1, bound2!);\n}\n","/**\n * Clamps a number within the inclusive upper bound.\n *\n * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified upper bound.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n */\nexport function clamp(value: number, maximum: number): number;\n\n/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, minimum: number, maximum: number): number;\n\n/**\n * Clamps a number within the specified bounds.\n *\n * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.\n * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (bound2 == null) {\n    return Math.min(value, bound1);\n  }\n\n  return Math.min(Math.max(value, bound1), bound2);\n}\n","/**\n * Converts `value` to a string.\n *\n * An empty string is returned for `null` and `undefined` values.\n * The sign of `-0` is preserved.\n *\n * @param {unknown} value - The value to convert.\n * @returns {string} Returns the converted string.\n *\n * @example\n * toString(null) // returns ''\n * toString(undefined) // returns ''\n * toString(-0) // returns '-0'\n * toString([1, 2, -0]) // returns '1,2,-0'\n * toString([Symbol('a'), Symbol('b')]) // returns 'Symbol(a),Symbol(b)'\n */\nexport function toString(value?: unknown): string {\n  if (value == null) {\n    return '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(toString).join(',');\n  }\n\n  const result = String(value);\n\n  if (result === '0' && Object.is(Number(value), -0)) {\n    return '-0';\n  }\n\n  return result;\n}\n","import { iteratee as iterateeToolkit } from '../util/iteratee.ts';\n\n/**\n * Computes the sum of the `number` values in `array`.\n *\n * @param {ArrayLike<number> | null | undefined} array - The array to iterate over.\n * @returns {number} Returns the sum.\n *\n * @example\n * sumBy([1, 2, 3]); // => 6\n * sumBy(null); // => 0\n * sumBy(undefined); // => 0\n */\nexport function sumBy(array: ArrayLike<number> | null | undefined): number;\n\n/**\n * Computes the sum of the `bigint` values in `array`.\n *\n * @param {ArrayLike<bigint>} array - The array to iterate over.\n * @returns {bigint} Returns the sum.\n *\n * @example\n * sumBy([1n, 2n, 3n]); // => 6n\n */\nexport function sumBy(array: ArrayLike<bigint>): bigint;\n/**\n * Computes the sum of the values in `array`.\n *\n * It does not coerce values to `number`.\n *\n * @param {ArrayLike<unknown> | null | undefined} array - The array to iterate over.\n * @returns {unknown} Returns the sum.\n *\n * @example\n * sumBy([\"1\", \"2\"]); // => \"12\"\n * sumBy([1, undefined, 2]); // => 3\n */\nexport function sumBy(array: ArrayLike<unknown> | null | undefined): unknown;\n\n/**\n * Computes the sum of the `number` values that are returned by the `iteratee` function.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T>} array - The array to iterate over.\n * @param {(value: T) => number} iteratee - The function invoked per iteration.\n * @returns {number} Returns the sum.\n *\n * @example\n * sumBy([{ a: 1 }, { a: 2 }, { a: 3 }], object => object.a); // => 6\n */\nexport function sumBy<T>(array: ArrayLike<T>, iteratee: (value: T) => number): number;\n\n/**\n * Computes the sum of the `bigint` values that are returned by the `iteratee` function.\n *\n * NOTE: If the `array` is empty, the function returns `0`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T>} array - The array to iterate over.\n * @param {(value: T) => bigint} iteratee - The function invoked per iteration.\n * @returns {bigint | number} Returns the sum.\n *\n * @example\n * sumBy([{ a: 1n }, { a: 2n }, { a: 3n }], object => object.a); // => 6n\n * sumBy([], (item: { a: bigint }) => item.a); // => 0\n */\nexport function sumBy<T>(array: ArrayLike<T>, iteratee: (value: T) => bigint): bigint | number;\n\n/**\n * Computes the sum of the values that are returned by the `iteratee` function.\n *\n * It does not coerce values to `number`.\n *\n * @template T - The type of the array elements.\n * @param {ArrayLike<T> | null | undefined} array - The array to iterate over.\n * @param {(value: T) => number | bigint} iteratee - The function invoked per iteration.\n * @returns {unknown} Returns the sum.\n *\n * @example\n * sumBy([1, undefined, 2], value => value); // => 3\n * sumBy(null); // => 0\n * sumBy(undefined); // => 0\n * sumBy([1, 2, 3]); // => 6\n * sumBy([1n, 2n, 3n]); // => 6n\n * sumBy([{ a: \"1\" }, { a: \"2\" }], object => object.a); // => \"12\"\n */\nexport function sumBy<T>(array: ArrayLike<T> | null | undefined, iteratee?: (value: T) => number | bigint): unknown {\n  if (!array || !array.length) {\n    return 0;\n  }\n\n  if (iteratee != null) {\n    iteratee = iterateeToolkit(iteratee);\n  }\n\n  let result: any = undefined;\n\n  for (let i = 0; i < array.length; i++) {\n    const current = iteratee ? iteratee(array[i]) : array[i];\n\n    if (current !== undefined) {\n      if (result === undefined) {\n        result = current;\n      } else {\n        result += current;\n      }\n    }\n  }\n\n  return result;\n}\n","export function isPrototype(value: {}) {\n  const constructor = value?.constructor;\n  const prototype = typeof constructor === 'function' ? constructor.prototype : Object.prototype;\n\n  return value === prototype;\n}\n","import { isTypedArray as isTypedArrayToolkit } from '../../predicate/isTypedArray.ts';\n\n/**\n * Checks if a value is a TypedArray.\n * @param {unknown} x The value to check.\n * @returns {x is\n *     Uint8Array\n *   | Uint8ClampedArray\n *   | Uint16Array\n *   | Uint32Array\n *   | BigUint64Array\n *   | Int8Array\n *   | Int16Array\n *   | Int32Array\n *   | BigInt64Array\n *   | Float32Array\n *   | Float64Array} Returns true if `x` is a TypedArray, false otherwise.\n *\n * @example\n * const arr = new Uint8Array([1, 2, 3]);\n * isTypedArray(arr); // true\n *\n * const regularArray = [1, 2, 3];\n * isTypedArray(regularArray); // false\n *\n * const buffer = new ArrayBuffer(16);\n * isTypedArray(buffer); // false\n */\nexport function isTypedArray(\n  x?: unknown\n): x is\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array {\n  return isTypedArrayToolkit(x);\n}\n","import { toInteger } from './toInteger.ts';\n\n/**\n * Invokes the getValue function n times, returning an array of the results.\n *\n * @template R The return type of the getValue function.\n * @param {number} n - The number of times to invoke getValue.\n * @param {(index: number) => R} getValue - The function to invoke for each index.\n * @returns {R[]} An array containing the results of invoking getValue n times.\n * @example\n * times(3, (i) => i * 2); // => [0, 2, 4]\n * times(2, () => 'es-toolkit'); // => ['es-toolkit', 'es-toolkit']\n */\nexport function times<R = number>(n?: number, getValue?: (index: number) => R): R[] {\n  n = toInteger(n);\n\n  if (n < 1 || !Number.isSafeInteger(n)) {\n    return [];\n  }\n\n  const result = new Array(n);\n\n  for (let i = 0; i < n; i++) {\n    result[i] = typeof getValue === 'function' ? getValue(i) : i;\n  }\n\n  return result;\n}\n","import { isBuffer } from '../../predicate/isBuffer.ts';\nimport { isPrototype } from '../_internal/isPrototype.ts';\nimport { isArrayLike } from '../predicate/isArrayLike.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\nimport { times } from '../util/times.ts';\n\n/**\n * This function retrieves the names of string-keyed properties from an object, including those inherited from its prototype.\n *\n * - If the value is not an object, it is converted to an object.\n * - Array-like objects are treated like arrays.\n * - Sparse arrays with some missing indices are treated like dense arrays.\n * - If the value is `null` or `undefined`, an empty array is returned.\n * - When handling prototype objects, the `constructor` property is excluded from the results.\n *\n * @param {unknown} [object] - The object to inspect for keys.\n * @returns {string[]} An array of string keys from the object.\n *\n * @example\n * const obj = { a: 1, b: 2 };\n * console.log(keysIn(obj)); // ['a', 'b']\n *\n * const arr = [1, 2, 3];\n * console.log(keysIn(arr)); // ['0', '1', '2']\n *\n * function Foo() {}\n * Foo.prototype.a = 1;\n * console.log(keysIn(new Foo())); // ['a']\n */\nexport function keysIn(object?: unknown): string[] {\n  if (object == null) {\n    return [];\n  }\n\n  switch (typeof object) {\n    case 'object':\n    case 'function': {\n      if (isArrayLike(object)) {\n        return arrayLikeKeysIn(object);\n      }\n\n      if (isPrototype(object)) {\n        return prototypeKeysIn(object);\n      }\n\n      return keysInImpl(object);\n    }\n\n    default: {\n      return keysInImpl(Object(object));\n    }\n  }\n}\n\nfunction keysInImpl(object: object): string[] {\n  const result: string[] = [];\n\n  for (const key in object) {\n    result.push(key);\n  }\n\n  return result;\n}\n\nfunction prototypeKeysIn(object: object): string[] {\n  const keys = keysInImpl(object);\n\n  return keys.filter(key => key !== 'constructor');\n}\n\nfunction arrayLikeKeysIn(object: ArrayLike<any>): string[] {\n  const indices = times(object.length, index => `${index}`);\n\n  const filteredKeys = new Set(indices);\n\n  if (isBuffer(object)) {\n    // Node.js 0.10 has enumerable non-index properties on buffers.\n    filteredKeys.add('offset');\n    filteredKeys.add('parent');\n  }\n\n  if (isTypedArray(object)) {\n    // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    filteredKeys.add('buffer');\n    filteredKeys.add('byteLength');\n    filteredKeys.add('byteOffset');\n  }\n\n  return [...indices, ...keysInImpl(object).filter(key => !filteredKeys.has(key))];\n}\n","import { keysIn } from './keysIn.ts';\nimport { eq } from '../util/eq.ts';\n\n/**\n * Assigns the properties of a source object to a target object.\n *\n * This function merges the properties of the source object into the target object,\n * including properties from the prototype chain. If a property in the source object\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S} source - The source object whose properties will be assigned to the target object.\n * @returns {O & S} The updated target object with properties from the source object assigned.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n * const result = assignIn(target, source);\n * console.log(result); // Output: { a: 1, b: 3, c: 4 }\n */\nexport function assignIn<O, S>(object: O, source: S): O & S;\n\n/**\n * Assigns the properties of two source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S1} source1 - The first source object whose properties will be assigned to the target object.\n * @param {S2} source2 - The second source object whose properties will be assigned to the target object.\n * @returns {O & S1 & S2} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const result = assignIn(target, source1, source2);\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn<O, S1, S2>(object: O, source1: S1, source2: S2): O & S1 & S2;\n\n/**\n * Assigns the properties of three source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S1} source1 - The first source object whose properties will be assigned to the target object.\n * @param {S2} source2 - The second source object whose properties will be assigned to the target object.\n * @param {S3} source3 - The third source object whose properties will be assigned to the target object.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const result = assignIn(target, source1, source2, source3);\n * console.log(result); // Output: { a: 1, b: 2, c: 3, d: 4 }\n */\nexport function assignIn<O, S1, S2, S3>(object: O, source1: S1, source2: S2, source3: S3): O & S1 & S2 & S3;\n\n/**\n * Assigns the properties of four source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {O} object - The target object to which properties will be assigned.\n * @param {S1} source1 - The first source object whose properties will be assigned to the target object.\n * @param {S2} source2 - The second source object whose properties will be assigned to the target object.\n * @param {S3} source3 - The third source object whose properties will be assigned to the target object.\n * @param {S4} source4 - The fourth source object whose properties will be assigned to the target object.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const source1 = { b: 2 };\n * const source2 = { c: 3 };\n * const source3 = { d: 4 };\n * const source4 = { e: 5 };\n * const result = assignIn(target, source1, source2, source3, source4);\n * console.log(result); // Output: { a: 1, b: 2, c: 3, d: 4, e: 5 }\n */\nexport function assignIn<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): O & S1 & S2 & S3;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignIn(target, { b: 2 }, { c: 3 }, { a: 4 });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn(object: any, ...sources: any[]): any;\n\n/**\n * Assigns properties from multiple source objects to a target object.\n *\n * This function merges the properties of the source objects into the target object,\n * including properties from the prototype chain. If a property in the source objects\n * is equal to the corresponding property in the target object, it will not be overwritten.\n *\n * @param {any} object - The target object to which properties will be assigned.\n * @param {...any[]} sources - The source objects whose properties will be assigned to the target object.\n * @returns {any} The updated target object with properties from the source objects assigned.\n *\n * @example\n * const target = { a: 1 };\n * const result = assignIn(target, { b: 2 }, { c: 3 });\n * console.log(result); // Output: { a: 1, b: 2, c: 3 }\n */\nexport function assignIn(object: any, ...sources: any[]): any {\n  for (let i = 0; i < sources.length; i++) {\n    assignInImpl(object, sources[i]);\n  }\n\n  return object;\n}\n\nfunction assignInImpl(object: any, source: any): any {\n  const keys = keysIn(source);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!(key in object) || !eq(object[key], source[key])) {\n      object[key] = source[key];\n    }\n  }\n}\n","import { eq } from '../util/eq.ts';\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @param {T} object - The target object.\n * @returns {T} The object itself.\n */\nexport function defaults<T extends object>(object: T): NonNullable<T>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S} source - The object that specifies the default values to apply.\n * @returns {NonNullable<T & S>} The `object` that has been updated with default values from `source`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S extends object>(object: T, source: S): NonNullable<T & S>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2>} The `object` that has been updated with default values from `source1` and `source2`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S1 extends object, S2 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2\n): NonNullable<T & S1 & S2>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3>} The `object` that has been updated with default values from `source1`, `source2`, and `source3`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S1 extends object, S2 extends object, S3 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3\n): NonNullable<T & S1 & S2 & S3>;\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S1 - The type of the first object that provides default values.\n * @template S2 - The type of the second object that provides default values.\n * @template S3 - The type of the third object that provides default values.\n * @template S4 - The type of the fourth object that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S1} source1 - The first object that specifies the default values to apply.\n * @param {S2} source2 - The second object that specifies the default values to apply.\n * @param {S3} source3 - The third object that specifies the default values to apply.\n * @param {S4} source4 - The fourth object that specifies the default values to apply.\n * @returns {NonNullable<T & S1 & S2 & S3 & S4>} The `object` that has been updated with default values from `source1`, `source2`, `source3`, and `source4`, ensuring that all properties are defined and none are left as `undefined`.\n */\nexport function defaults<T extends object, S1 extends object, S2 extends object, S3 extends object, S4 extends object>(\n  object: T,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4\n): NonNullable<T & S1 & S2 & S3 & S4>;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} source - The objects that specifies the default values to apply.\n * @returns {object} The `object` that has been updated with default values from `sources`, ensuring that all properties are defined and none are left as `undefined`.\n *\n * @example\n * defaults({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: null }, { a: 1 }); // { a: null }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults<T extends object, S extends object>(object: T, ...sources: S[]): object;\n\n/**\n * Assigns default values to an `object`, ensuring that certain properties do not remain `undefined`.\n * It sets default values for properties that are either `undefined` or inherited from `Object.prototype`.\n *\n * You can pass in multiple objects to define these default values,\n * and they will be applied in order from left to right.\n * Once a property has been assigned a value, any subsequent values for that property will be ignored.\n *\n * Note: This function modifies the first argument, `object`. If you want to keep `object` unchanged, consider using `toDefaulted` instead.\n *\n * @template T - The type of the object being processed.\n * @template S - The type of the objects that provides default values.\n * @param {T} object - The target object that will receive default values.\n * @param {S[]} source - The objects that specifies the default values to apply.\n * @returns {object} The `object` that has been updated with default values from `sources`, ensuring that all properties are defined and none are left as `undefined`.\n *\n * @example\n * defaults({ a: 1 }, { a: 2, b: 2 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: 1, b: 2 }, { b: 3 }, { c: 3 }); // { a: 1, b: 2, c: 3 }\n * defaults({ a: null }, { a: 1 }); // { a: null }\n * defaults({ a: undefined }, { a: 1 }); // { a: 1 }\n */\nexport function defaults<T extends object, S extends object>(object: T, ...sources: S[]): object {\n  object = Object(object);\n  const objectProto = Object.prototype;\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    const keys = Object.keys(source) as Array<keyof S>;\n\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j];\n      const value = (object as any)[key];\n\n      if (\n        value === undefined ||\n        (!Object.hasOwn(object, key) && eq(value, objectProto[key as keyof typeof objectProto]))\n      ) {\n        (object as any)[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n}\n","/**\n * Checks if a given value is a plain object.\n *\n * A plain object is an object created by the `{}` literal, `new Object()`, or\n * `Object.create(null)`.\n *\n * This function also handles objects with custom\n * `Symbol.toStringTag` properties.\n *\n * `Symbol.toStringTag` is a built-in symbol that a constructor can use to customize the\n * default string description of objects.\n *\n * @param {unknown} [object] - The value to check.\n * @returns {boolean} - True if the value is a plain object, otherwise false.\n *\n * @example\n * console.log(isPlainObject({})); // true\n * console.log(isPlainObject([])); // false\n * console.log(isPlainObject(null)); // false\n * console.log(isPlainObject(Object.create(null))); // true\n * console.log(isPlainObject(new Map())); // false\n */\nexport function isPlainObject(object?: unknown): boolean {\n  if (typeof object !== 'object') {\n    return false;\n  }\n\n  if (object == null) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(object) === null) {\n    return true;\n  }\n\n  if (Object.prototype.toString.call(object) !== '[object Object]') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tag = object[Symbol.toStringTag];\n\n    if (tag == null) {\n      return false;\n    }\n\n    const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n\n    if (isTagReadonly) {\n      return false;\n    }\n\n    return object.toString() === `[object ${tag}]`;\n  }\n\n  let proto = object;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(object) === proto;\n}\n","import { cloneDeep } from './cloneDeep.ts';\nimport { clone } from '../../object/clone.ts';\nimport { isPrimitive } from '../../predicate/isPrimitive.ts';\nimport { getSymbols } from '../_internal/getSymbols.ts';\nimport { isArguments } from '../predicate/isArguments.ts';\nimport { isObjectLike } from '../predicate/isObjectLike.ts';\nimport { isPlainObject } from '../predicate/isPlainObject.ts';\nimport { isTypedArray } from '../predicate/isTypedArray.ts';\n\ndeclare let Buffer:\n  | {\n      isBuffer: (a: any) => boolean;\n    }\n  | undefined;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The first source object whose properties will be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {T & S} The updated target object with properties from the source object(s) merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the first source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<T, S>(\n  target: T,\n  source: S,\n  merge: (targetValue: any, sourceValue: any, key: string, target: T, source: S, stack: Map<any, any>) => any\n): T & S;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object to be merged into the target object.\n * @param {S2} source2 - The second source object to be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {O & S1 & S2} The updated target object with properties from the source objects merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {O & S1 & S2 & S3} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2, S3>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {O} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S1} source1 - The first source object whose properties will be merged into the target object.\n * @param {S2} source2 - The second source object whose properties will be merged into the target object.\n * @param {S3} source3 - The third source object whose properties will be merged into the target object.\n * @param {S4} source4 - The fourth source object whose properties will be merged into the target object.\n * @param {(targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any} merge - The function to customize merging properties.\n * @returns {O & S1 & S2 & S3 & S4} The updated target object with properties from the source object(s) merged in.\n *\n * @template O - Type of the target object.\n * @template S1 - Type of the first source object.\n * @template S2 - Type of the second source object.\n * @template S3 - Type of the third source object.\n * @template S4 - Type of the fourth source object.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith<O, S1, S2, S3, S4>(\n  object: O,\n  source1: S1,\n  source2: S2,\n  source3: S3,\n  source4: S4,\n  merge: (targetValue: any, sourceValue: any, key: string, target: any, source: any, stack: Map<any, any>) => any\n): O & S1 & S2 & S3;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any;\n\n/**\n * Merges the properties of one or more source objects into the target object.\n *\n * This function performs a deep merge, recursively merging nested objects and arrays.\n * If a property in the source object is an array or object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is `undefined`, it will not overwrite a defined property in the target object.\n *\n * You can provide a custom `merge` function to control how properties are merged. The `merge` function is called for each property that is being merged and receives the following arguments:\n *\n * - `targetValue`: The current value of the property in the target object.\n * - `sourceValue`: The value of the property in the source object.\n * - `key`: The key of the property being merged.\n * - `target`: The target object.\n * - `source`: The source object.\n * - `stack`: A `Map` used to keep track of objects that have already been processed to handle circular references.\n *\n * The `merge` function should return the value to be set in the target object. If it returns `undefined`, a default deep merge will be applied for arrays and objects.\n *\n * The function can handle multiple source objects and will merge them all into the target object.\n *\n * @param {any} object - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {any[]} sources - The source objects whose properties will be merged into the target object.\n * @param {...any} otherArgs - Additional source objects to merge into the target object, including the custom `merge` function.\n * @returns {any} The updated target object with properties from the source object(s) merged in.\n *\n * @example\n * const target = { a: 1, b: 2 };\n * const source = { b: 3, c: 4 };\n *\n * mergeWith(target, source, (targetValue, sourceValue) => {\n *   if (typeof targetValue === 'number' && typeof sourceValue === 'number') {\n *     return targetValue + sourceValue;\n *   }\n * });\n * // Returns { a: 1, b: 5, c: 4 }\n * @example\n * const target = { a: [1], b: [2] };\n * const source = { a: [3], b: [4] };\n *\n * const result = mergeWith(target, source, (objValue, srcValue) => {\n *   if (Array.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * });\n *\n * expect(result).toEqual({ a: [1, 3], b: [2, 4] });\n */\nexport function mergeWith(object: any, ...otherArgs: any[]): any {\n  const sources = otherArgs.slice(0, -1);\n  const merge = otherArgs[otherArgs.length - 1] as (\n    targetValue: any,\n    sourceValue: any,\n    key: string | symbol,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any;\n\n  let result = object;\n\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n\n    result = mergeWithDeep(result, source, merge, new Map());\n  }\n\n  return result;\n}\n\nfunction mergeWithDeep(\n  target: any,\n  source: any,\n  merge: (\n    targetValue: any,\n    sourceValue: any,\n    key: string | symbol,\n    target: any,\n    source: any,\n    stack: Map<any, any>\n  ) => any,\n  stack: Map<any, any>\n) {\n  if (isPrimitive(target)) {\n    target = Object(target);\n  }\n\n  if (source == null || typeof source !== 'object') {\n    return target;\n  }\n\n  if (stack.has(source)) {\n    return clone(stack.get(source));\n  }\n\n  stack.set(source, target);\n\n  if (Array.isArray(source)) {\n    source = source.slice();\n    for (let i = 0; i < source.length; i++) {\n      source[i] = source[i] ?? undefined;\n    }\n  }\n\n  const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n\n    let sourceValue = source[key];\n    let targetValue = target[key];\n\n    if (isArguments(sourceValue)) {\n      sourceValue = { ...sourceValue };\n    }\n\n    if (isArguments(targetValue)) {\n      targetValue = { ...targetValue };\n    }\n\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n      sourceValue = cloneDeep(sourceValue);\n    }\n\n    if (Array.isArray(sourceValue)) {\n      if (typeof targetValue === 'object' && targetValue != null) {\n        const cloned: any = [];\n        const targetKeys = Reflect.ownKeys(targetValue);\n\n        for (let i = 0; i < targetKeys.length; i++) {\n          const targetKey = targetKeys[i];\n          cloned[targetKey] = targetValue[targetKey];\n        }\n\n        targetValue = cloned;\n      } else {\n        targetValue = [];\n      }\n    }\n\n    const merged = merge(targetValue, sourceValue, key, target, source, stack);\n\n    if (merged != null) {\n      target[key] = merged;\n    } else if (Array.isArray(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n      target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n    } else if (targetValue == null && isPlainObject(sourceValue)) {\n      target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n    } else if (targetValue == null && isTypedArray(sourceValue)) {\n      target[key] = cloneDeep(sourceValue);\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","import { get } from './get.ts';\nimport { isDeepKey } from '../_internal/isDeepKey.ts';\nimport { toKey } from '../_internal/toKey.ts';\nimport { toPath } from '../util/toPath.ts';\n\n/**\n * Removes the property at the given path of the object.\n *\n * @param {unknown} obj - The object to modify.\n * @param {PropertyKey | readonly PropertyKey[]} path - The path of the property to unset.\n * @returns {boolean} - Returns true if the property is deleted, else false.\n *\n * @example\n * const obj = { a: { b: { c: 42 } } };\n * unset(obj, 'a.b.c'); // true\n * console.log(obj); // { a: { b: {} } }\n *\n * @example\n * const obj = { a: { b: { c: 42 } } };\n * unset(obj, ['a', 'b', 'c']); // true\n * console.log(obj); // { a: { b: {} } }\n */\nexport function unset(obj: any, path: PropertyKey | readonly PropertyKey[]): boolean {\n  if (obj == null) {\n    return true;\n  }\n\n  switch (typeof path) {\n    case 'symbol':\n    case 'number':\n    case 'object': {\n      if (Array.isArray(path)) {\n        return unsetWithPath(obj, path);\n      }\n\n      if (typeof path === 'number') {\n        path = toKey(path);\n      } else if (typeof path === 'object') {\n        if (Object.is(path?.valueOf(), -0)) {\n          path = '-0';\n        } else {\n          path = String(path);\n        }\n      }\n\n      if (obj?.[path] === undefined) {\n        return true;\n      }\n\n      try {\n        delete obj[path];\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    case 'string': {\n      if (obj?.[path] === undefined && isDeepKey(path)) {\n        return unsetWithPath(obj, toPath(path));\n      }\n\n      try {\n        delete obj[path];\n        return true;\n      } catch {\n        return false;\n      }\n    }\n  }\n}\n\nfunction unsetWithPath(obj: unknown, path: readonly PropertyKey[]): boolean {\n  const parent = get(obj, path.slice(0, -1), obj);\n  const lastKey = path[path.length - 1];\n\n  if (parent?.[lastKey] === undefined) {\n    return true;\n  }\n\n  try {\n    delete parent[lastKey];\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/**\n * Checks if `object` conforms to `source` by invoking the predicate properties of `source` with the corresponding property values of `object`.\n *\n * Note: This method is equivalent to `conforms` when source is partially applied.\n *\n * @param {Record<PropertyKey, any>} target The object to inspect.\n * @param {Record<PropertyKey, (value: any) => boolean>} source The object of property predicates to conform to.\n * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n *\n * @example\n *\n * const object = { 'a': 1, 'b': 2 };\n * const source = {\n *   'a': (n) => n > 0,\n *   'b': (n) => n > 1\n * };\n *\n * console.log(conformsTo(object, source)); // => true\n *\n * const source2 = {\n *   'a': (n) => n > 1,\n *   'b': (n) => n > 1\n * };\n *\n * console.log(conformsTo(object, source2)); // => false\n */\nexport function conformsTo(\n  target: Record<PropertyKey, any>,\n  source: Record<PropertyKey, (value: any) => boolean>\n): boolean {\n  if (source == null) {\n    return true;\n  }\n\n  if (target == null) {\n    return Object.keys(source).length === 0;\n  }\n\n  const keys = Object.keys(source);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const predicate = source[key];\n    const value = target[key];\n    if ((value === undefined && !(key in target)) || !predicate(value)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { isMap as isMapToolKit } from '../../predicate/isMap.ts';\n\n/**\n * Checks if a given value is `Map`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\n *\n * @param {unknown} value The value to check if it is a `Map`.\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\n *\n * @example\n * const value1 = new Map();\n * const value2 = new Set();\n * const value3 = new WeakMap();\n *\n * console.log(isMap(value1)); // true\n * console.log(isMap(value2)); // false\n * console.log(isMap(value3)); // false\n */\n\nexport function isMap(value?: unknown): value is Map<any, any> {\n  return isMapToolKit(value);\n}\n","/**\n * Checks if a given value is `Map`.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `Map`.\n *\n * @param {unknown} value The value to check if it is a `Map`.\n * @returns {value is Map<any, any>} Returns `true` if `value` is a `Map`, else `false`.\n *\n * @example\n * const value1 = new Map();\n * const value2 = new Set();\n * const value3 = new WeakMap();\n *\n * console.log(isMap(value1)); // true\n * console.log(isMap(value2)); // false\n * console.log(isMap(value3)); // false\n */\n\nexport function isMap(value: unknown): value is Map<any, any> {\n  return value instanceof Map;\n}\n","import { toString } from '../util/toString.ts';\n\nexport function normalizeForCase(str: unknown): string {\n  // Coerce to string\n  if (typeof str !== 'string') {\n    str = toString(str);\n  }\n\n  // Remove contraction apostrophes\n  return (str as string).replace(/['\\u2019]/g, '');\n}\n","import { escape as escapeToolkit } from '../../string/escape.ts';\nimport { toString } from '../util/toString.ts';\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `str` to their corresponding HTML entities.\n * For example, \"<\" becomes \"&lt;\".\n *\n * @param {string} str  The string to escape.\n * @returns {string} Returns the escaped string.\n *\n * @example\n * escape('This is a <div> e